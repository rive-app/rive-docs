---
title: 'Data Binding'
description: 'Connect your code to bound editor elements using View Models'
---

import { YouTube } from '/snippets/youtube.mdx'
import { EarlyAccessFeature } from '/snippets/early-access-feature.mdx'

export const DataBindingReact = () => {
  return (
    <Info>
    Hooks for data binding will soon be available in the Rive React package. In the meantime, you can use the Web API in React. Check back here for updates.
    </Info>
  );
};

# Overview

Before engaging with the runtime data binding APIs, it is important to familiarize yourself with the core concepts presented in the [Overview](/editor/data-binding/overview).

<Card title="Data Binding Concepts" href="/editor/data-binding/overview"  icon={<svg xmlns="http://www.w3.org/2000/svg" height="100%" fill="none" viewBox="0 0 16 16" class="size-4 text-gray-500/80 dark:text-gray-400" aria-hidden="true"><path fill="currentColor" d="M7.31 7.111 2.406 5.15l4.61-1.844.328-.126a2.3 2.3 0 0 1 1.647 0l.33.126L13.93 5.15 9.024 7.112c-.55.22-1.163.22-1.712 0"></path><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m2.405 10.911 4.906 1.963c.55.22 1.162.22 1.712 0l4.906-1.963M2.405 8.031 7.31 9.992c.55.22 1.162.22 1.712 0l4.906-1.963M2.405 5.15 7.31 7.111c.55.22 1.162.22 1.712 0l4.906-1.962-4.61-1.844-.329-.126a2.3 2.3 0 0 0-1.647 0l-.329.126z"></path></svg>}>
    An overview of core data binding concepts.
</Card>

# View Models

View models describe a set of properties, but cannot themselves be used to get or set values - that is the role of [view model instances](#view-model-instances).

To begin, we need to get a reference to a particular view model. This can be done either by index, by name, or the default for a given artboard, and is done from the Rive file. The default option refers to the view model assigned to an artboard by the dropdown in the editor.

<Tabs>
    <Tab title="Web">
    Access a View Model from the created Rive object in the `onLoad` callback:

    ```typescript
    const rive = new rive.Rive({
        onLoad: () => {
            // The Rive object is now loaded and ready to use.
        }
    });
    ````
    Once Rive is loaded, you can access the view models using the following methods:
    ```typescript
    // Get reference by name
    const namedVM = rive.viewModelByName("My View Model");

    // Get reference by index
    for (let i = 0; i < rive.viewModelCount; i++) {
        const indexedVM = rive.viewModelByIndex(i);
    }

    // Get reference to the default view model
    const defaultVM = rive.defaultViewModel();
    ```

    Alternatively, if you have access to the underlying Rive File object you can access the above methods on the file.
    ```typescript
    const namedVM = file.viewModelByName("My View Model");
    const indexedVM = file.viewModelByIndex(0);
    const defaultVM = file.defaultArtboardViewModel(artboard);
    ```
    </Tab>
    <Tab title="React">
        Use the `useViewModel` hook to get a reference to a view model. You need to pass the `rive` object obtained from `useRive`.

        ```typescript
        import { useRive, useViewModel } from '@rive-app/react-webgl2';

        const { rive, RiveComponent } = useRive({
            src: 'your_file.riv',
            // ... other options
        });

        // Option 1: Get the default ViewModel for the artboard
        const defaultViewModel = useViewModel(rive);

        // Option 2: Get the default ViewModel explicitly
        const defaultViewModelExplicit = useViewModel(rive, { useDefault: true });

        // Option 3: Get a ViewModel by its name
        const namedViewModel = useViewModel(rive, { name: 'MyViewModelName' });
        ```
    </Tab>
    <Tab title="Apple">
        ```swift
        let riveViewModel = RiveViewModel(...)
        let file = riveViewModel.riveModel!.riveFile

        // Data binding view model by name
        let viewModelByName = file.viewModelNamed("...")

        // Data binding view model by index
        for index in 0..<file.viewModelCount {
            let viewModelByIndex = file.viewModel(at: index)
        }

        // Default data binding view model for an artboard
        let artboard = riveViewModel.riveModel!.artboard
        let viewModelForArtboard = file.viewModel(for: artboard)
        ```
    </Tab>
    <Tab title="Android">
        ```kotlin
        // `view` of type RiveAnimationView
        view.setRiveResource(R.raw.my_rive_file)
        val file = view.controller.file!!

        // Get reference by name
        val vm = file.getViewModelByName("My View Model")

        // Get reference by index
        for (i in 0 until file.viewModelCount) {
            val indexedVM = file.getViewModelByIndex(i)
        }

        // Get reference to the default view model
        val defaultVM = file.defaultViewModelForArtboard(view.controller.activeArtboard!!)
        ```
    </Tab>
    <Tab title="Flutter">
        ```dart
        // Get reference to the File and Artboard
        final file = await File.asset(
            'assets/my_file.riv',
            riveFactory: Factory.rive,
        );
        final artboard = file!.defaultArtboard()!;

        // Get reference by name
        file.viewModelByName("My View Model");

        // Get reference by index
        for (var i = 0; i < file.viewModelCount; i++) {
            final indexedVM = file.viewModelByIndex(i);
        }

        // Get reference to the default view model for an artboard
        final defaultVM = file.defaultArtboardViewModel(artboard);

        // Dispose the view model when you're no longer using it
        viewModel.dispose();
        ```
    </Tab>
    <Tab title="Unity">
        <Note>
        These APIs are only needed when the `Data Binding Mode` on the RiveWidget is set to `Manual`.

        Otherwise, you can configure view model binding directly in the Unity Inspector under the Data section.
        </Note>
        ```csharp
        private void OnEnable()
        {
            riveWidget.OnWidgetStatusChanged += HandleWidgetStatusChanged;
        }

        private void OnDisable()
        {
            riveWidget.OnWidgetStatusChanged -= HandleWidgetStatusChanged;
        }

        private void HandleWidgetStatusChanged()
        {
            if (riveWidget.Status == WidgetStatus.Loaded)
            {
                File file = riveWidget.File;

                // Get reference by name
                ViewModel viewModel = file.GetViewModelByName("My View Model");

                // Get reference by index
                for (int i = 0; i < file.ViewModelCount; i++)
                {
                    ViewModel indexedVM = file.GetViewModelAtIndex(i);
                }

                // Get reference to the default view model for an artboard
                ViewModel defaultVM = riveWidget.Artboard.DefaultViewModel;
            }
        }
        ```
    </Tab>
    <Tab title="React Native">
        In React Native you cannot directly instantiate a view model and pass it to Rive. Instead, React Native will always use the view model
        that is bound to the artboard - as set in the editor.

        This is because in React Native, you do not have direct control over the Rive file, the artboard, or the state machine.
        What you can control is the instance of the view model. See below.

        <Info>
        A future version of Rive for React Native may allow for similar control as the other runtimes.
        </Info>

    </Tab>
</Tabs>

# View Model Instances

Once we have a reference to a view model, it can be used to create an instance. When creating an instance, you have four options:

1. Create a blank instance - Fill the properties of the created instance with default values as follows:

    | Type              | Value           |
    |-------------------|-----------------|
    | Number            | 0               |
    | String            | Empty string    |
    | Boolean           | False           |
    | Color             | 0xFF000000      |
    | Trigger           | Untriggered     |
    | Enum              | The first value |
    | Nested view model | Null            |

2. Create the default instance - Use the instance labelled "Default" in the editor. Usually this is the one a designer intends as the primary one to be used at runtime.

3. Create by index - Using the order returned when iterating over all available instances. Useful when creating multiple instances by iteration.

4. Create by name - Use the editor's instance name. Useful when creating a specific instance.

<Tabs>
    <Tab title="Web">
    ```typescript
    // Create a blank instance from a view model (ViewModel)
    const vmiBlank = viewModel.instance();

    // Create a default instance from a view model (ViewModel)
    const vmiDefault = viewModel.defaultInstance();

    // Create an instance by index from a view model (ViewModel)
    for (let i = 0; i < viewModel.instanceCount; i++) {
        const vmiIndexed = viewModel.instanceByIndex(i);
    }

    // Create an instace by name from a view model (ViewModel)
    const vmiNamed = viewModel.instanceByName("My Instance");
    ```
    </Tab>
    <Tab title="React">
        Use the `useViewModelInstance` hook to create a view model instance from a view model returned by the `useViewModel` hook.

        ```typescript
        import { useRive, useViewModel, useViewModelInstance } from '@rive-app/react-webgl2';

        const { rive, RiveComponent } = useRive({
            src: 'your_file.riv',
            artboard: 'MyArtboard',
            stateMachine: 'MyStateMachine',
            // ... other options
        });

        const viewModel = useViewModel(rive, { name: 'MyViewModelName' });
        // Or: const viewModel = useViewModel(rive); // Default VM

        // Get default instance without binding
        const defaultUnbound = useViewModelInstance(viewModel, { useDefault: true });

        // Get named instance without binding
        const namedUnbound = useViewModelInstance(viewModel, { name: 'MyInstanceName' });

        // Create new blank instance without binding
        const newUnbound = useViewModelInstance(viewModel, { useNew: true });
        ```

        You can also bind the view model instance directly to the Rive instance by passing the `rive` object to the `useViewModelInstance` hook.

        ```typescript
        import { useRive, useViewModel, useViewModelInstance } from '@rive-app/react-webgl2';

        const { rive, RiveComponent } = useRive({
            src: 'your_file.riv',
            artboard: 'MyArtboard',
            stateMachine: 'MyStateMachine',
            autoBind: false, // Disable auto binding so we can manually bind later
            // ... other options
        });

        const viewModel = useViewModel(rive, { name: 'MyViewModelName' });

        // Get default instance (implicit) and bind it
        const defaultBound = useViewModelInstance(viewModel, { rive });

        // Get named instance and bind it
        const namedBound = useViewModelInstance(viewModel, { name: 'MyInstanceName', rive });

        // Create a new blank instance and bind it
        const newBound = useViewModelInstance(viewModel, { useNew: true, rive });
        ```

        If you set `autoBind: true` in `useRive`, you can access the automatically bound default instance directly via `rive.viewModelInstance` once Rive is loaded, without needing `useViewModel` or `useViewModelInstance`.

        ```typescript
        const { rive, RiveComponent } = useRive({
            src: 'your_file.riv',
            artboard: 'MyArtboard',
            stateMachine: 'MyStateMachine',
            autoBind: true,
        });

        // Once loaded, the instance is available:
        const boundInstance = rive?.viewModelInstance;
        ```
    </Tab>
    <Tab title="Apple">
    ```swift
        let riveViewModel = RiveViewModel(...)
        let viewModel = riveViewModel.riveModel!.riveFile.viewModelNamed("...")!

        // Create blank
        let blankInstance = viewModel.createInstance()

        // Create default
        let defaultInstance = viewModel.createDefaultInstance()

        // Create by index
        for index in 0..<viewModel.instanceCount {
            let instanceByIndex = viewModel.createInstance(fromIndex: index)
        }

        // Create by name
        for name in viewModel.instanceNames {
            let instanceByName = viewModel.createInstance(fromName: name)
        }
    ```
    </Tab>
    <Tab title="Android">
        ```kotlin
        val vm = view.controller.file?.getViewModelByName("My View Model")!!

        // Create blank
        val vmiBlank = vm.createBlankInstance()

        // Create default
        val vmiDefault = vm.createDefaultInstance()

        // Create by index
        for (i in 0 until vm.instanceCount) {
            val vmiIndexed = vm.createInstanceFromIndex(i)
        }

        // Create by name
        val vmiNamed = vm.createInstanceFromName("My Instance")
        ```
    </Tab>
    <Tab title="Flutter">
        ```dart
        final vm = file.viewModelByName("My View Model")!;

        // Create blank
        final vmiBlank = vm.createInstance();

        // Create default
        final vmiDefault = vm.createDefaultInstance();

        // Create by index
        for (int i = 0; i < vm.instanceCount; i++) {
        final vmiIndexed = vm.createInstanceByIndex(i);
        }

        // Create by name
        final vmiNamed = vm.createInstanceByName("My Instance");

        // Dispose the view model instance
        viewModelInstance.dispose();
        ```
    </Tab>
    <Tab title="Unity">
        <Note>
        These APIs are only needed when the `Data Binding Mode` on the RiveWidget is set to `Manual`.

        Otherwise, you can configure view model binding directly in the Unity Inspector under the Data section.
        </Note>
        ```csharp
        private void OnEnable()
        {
            riveWidget.OnWidgetStatusChanged += HandleWidgetStatusChanged;
        }

        private void OnDisable()
        {
            riveWidget.OnWidgetStatusChanged -= HandleWidgetStatusChanged;
        }

        private void HandleWidgetStatusChanged()
        {
            if (riveWidget.Status == WidgetStatus.Loaded)
            {
                // From a ViewModel reference
                ViewModel vm = riveWidget.File.GetViewModelByName("My View Model");

                // Create blank
                ViewModelInstance vmiBlank = vm.CreateInstance();

                // Create default
                ViewModelInstance vmiDefault = vm.CreateDefaultInstance();

                // Create by index
                for (int i = 0; i < vm.InstanceCount; i++)
                {
                    ViewModelInstance vmiIndexed = vm.CreateInstanceAt(i);
                }

                // Create by name
                ViewModelInstance vmiNamed = vm.CreateInstanceByName("My Instance");
            }
        }
        ```
    </Tab>
     <Tab title="React Native">
        You can bind a view model instance to a Rive component by passing in a `dataBinding` prop to the Rive component.

        The `dataBinding` prop accepts a `DataBindBy` type, which can be one of the following:
        ```typescript
        export type DataBindBy =
            | { type: 'autobind'; value: boolean }
            | { type: 'index'; value: number }
            | { type: 'name'; value: string }
            | { type: 'empty' };

        export const AutoBind = (value: boolean): DataBindBy => ({
            type: 'autobind',
            value,
        });
        export const BindByIndex = (value: number): DataBindBy => ({
            type: 'index',
            value,
        });
        export const BindByName = (value: string): DataBindBy => ({
            type: 'name',
            value,
        });
        export const BindEmpty = (): DataBindBy => ({ type: 'empty' });
        ```

        Example usage:
        ```typescript {7-10}
        const [setRiveRef, riveRef] = useRive();

        return (
            <Rive
                ref={setRiveRef}
                autoplay={true}
                dataBinding={AutoBind(true)} // default: `AutoBind(false)`
                // dataBinding={BindByIndex(0)}
                // dataBinding={BindByName('SomeName')}
                // dataBinding={BindEmpty()}
                stateMachineName={'State Machine 1'}
                resourceName={'rewards'}
            />
        );
        ```

        You can listen to errors by passing in the `onError={(riveError: RNRiveError)` prop to the Rive component.
        The `riveError` object contains the error type and message, and you can filter out for `RNRiveErrorType.DataBindingError`:

        ```typescript
        onError={(riveError: RNRiveError) => {
            switch (riveError.type) {
                case RNRiveErrorType.DataBindingError: {
                console.error(`${riveError.message}`);
                return;
                }
                default:
                console.error('Unhandled error');
                return;
            }
        }}
        ```

    </Tab>
</Tabs>

The created instance can then be assigned to a state machine or artboard. This establishes the bindings set up at edit time.

It is preferred to assign to a state machine, as this will automatically apply the instance to the artboard as well. Only assign to an artboard if you are not using a state machine, i.e. your file is static or uses linear animations.

<Note>The initial values of the instance are not applied to their bound elements until the state machine or artboard advances.</Note>

<Tabs>
    <Tab title="Web">
    ```typescript
    const rive = new rive.Rive({
        autoBind: false, // This should be set to false (default)
        onLoad: () => {
            const vm = rive.viewModelByName("My View Model");
            const vmi = vm.instanceByName("My Instance");

            // Manually bind by applying the instance to the state machine and artboard
            rive.bindViewModelInstance(vmi);
        }
    });
    ```
    </Tab>
    <Tab title="React">
        For React, no additional steps are needed to bind the view model instance to the Rive component. Passing the `rive` object to `useViewModelInstance` handles this automatically.
    </Tab>
    <Tab title="Apple">
        ```swift
        let riveViewModel = RiveViewModel(...)
        let artboard = riveViewModel.riveModel!.artboard,
        let instance = riveViewModel.riveModel!.riveFile.defaultViewModel(for: artboard).createDefaultInstance()!

        // Apply the instance to the state machine (preferred)
        // Applying to a state machine will automatically bind to its artboard
        riveViewModel.riveModel!.stateMachine.bind(instance)

        // Alternatively, apply the instance to the artboard
        artboard.bind(viewModelInstance: instance)
        ```
    </Tab>
    <Tab title="Android">
        ```kotlin
        view.setRiveResource(
            R.raw.my_rive_file,
            artboardName = "My Artboard",
        )

        val vm = view.controller.file?.getViewModelByName("My View Model")!!
        val vmi = vm.createInstanceFromName("My Instance")

        // Apply the instance to the state machine (preferred)
        view.controller.stateMachines.first().viewModelInstance = vmi

        // Alternatively, apply the instance to the artboard
        view.controller.activeArtboard?.viewModelInstance = vmi
        ```
    </Tab>
    <Tab title="Flutter">
        ```dart
        final file = await File.asset(
        'assets/my_file.riv',
        riveFactory: Factory.rive,
        );

        final artboard = file!.defaultArtboard();
        final stateMachine = artboard!.defaultStateMachine()!;

        final vm = file.defaultArtboardViewModel(artboard)!;
        final vmi = vm.createDefaultInstance()!;

        // Bind to the state machine. This automatically binds to the artboard as well.
        stateMachine.bindViewModelInstance(vmi);

        // If you're not using a state machine, bind to the artboard
        artboard.bindViewModelInstance(vmi);
        ```
    </Tab>
    <Tab title="Unity">
        ```csharp
        // Access the RiveWidget component

        // Using the Unity Inspector
        // 1. Select your RiveWidget in the Inspector
        // 2. In the "Data" section, set the Data Binding Mode:
        //    - Auto Bind Default: Automatically binds the default view model instance
        //    - Auto Bind Selected: Uses a specific instance you select in the dropdown
        //    - Manual: Requires you to manually set up binding in code

        // Or programmatically if set to Manual or if using the low-level API
        private void OnEnable()
        {
            riveWidget.OnWidgetStatusChanged += HandleWidgetStatusChanged;
        }

        private void OnDisable()
        {
            riveWidget.OnWidgetStatusChanged -= HandleWidgetStatusChanged;
        }

        private void HandleWidgetStatusChanged()
        {
            if (riveWidget.Status == WidgetStatus.Loaded)
            {
                ViewModel vm = riveWidget.Artboard.DefaultViewModel;
                ViewModelInstance vmi = vm.CreateDefaultInstance();

                // Applying to a state machine will automatically bind to its artboard
                riveWidget.StateMachine.BindViewModelInstance(vmi);
            }
        }

        ```
    </Tab>
     <Tab title="React Native">
        For React Native, no additional steps are needed to bind the view model instance to the Rive component. The `dataBinding` prop handles this automatically.
    </Tab>
</Tabs>

### Auto-Binding

Alternatively, you may prefer to use auto-binding. This will automatically bind the default view model of the artboard using the default instance to both the state machine and the artboard. The default view model is the one selected on the artboard in the editor dropdown. The default instance is the one marked "Default" in the editor.

<Tabs>
    <Tab title="Web">
    ```typescript {4}
    const rive = new rive.Rive({
        src: "my_rive_file.riv",
        canvas: document.getElementById("canvas"),
        autoBind: true,
        onLoad: () => {
            // Access the current instance that was auto-bound
            let boundInstance = rive.viewModelInstance;
        }
    });
    ```
    </Tab>
    <Tab title="React">
            ```typescript
            const { rive, RiveComponent } = useRive({
                src: 'your_file.riv',
                artboard: 'MyArtboard',
                stateMachine: 'MyStateMachine',
                autoBind: true, // Enable auto-binding
                // ... other options
            });

            // Once loaded, the instance is available:
            const boundInstance = rive?.viewModelInstance;
            ```
    </Tab>
    <Tab title="Apple">
        ```swift
        let riveViewModel = RiveViewModel(...)
        riveViewModel.riveModel.enableAutoBind { instance in
            // Store a reference to `instance` to later access properties
            // The instance may change as state machines and artboards change
        }

        // If you'd like to disable autoBind after enablingâ€¦
        riveViewModel.riveModel!.disableAutoBind()
        ```
    </Tab>
    <Tab title="Android">
        ```kotlin {3}
        view.setRiveResource(
            R.raw.my_rive_file,
            autoBind = true,
        )
        ```
    </Tab>
    <Tab title="Flutter">
        <Info>
        Flutter (rive_native) does not support auto-binding at this time. Higher level widgets will expose this functionality in the future.

        See the `RivePlayer.dart` file in the example app for a demo of how this will be presented.
      </Info>
    </Tab>
    <Tab title="Unity">
        **Rive Widget** provides both visual and programmatic ways to configure auto-binding. In the Inspector, you can easily set up binding through the Data Binding Mode dropdown:

        ![Data Binding Mode dropdown in Unity Inspector showing Auto Bind options](/images/unity/widget-db-binding-mode-dropdown.jpg)

        To enable auto-binding programmatically, use the following APIs:

        ```csharp

        // Before the widget is loaded:

        // Option 1: Auto bind the default instance
        riveWidget.BindingMode = DataBindingMode.AutoBindDefault;

        // Option 2: Auto bind a specific instance by name
        riveWidget.BindingMode = DataBindingMode.AutoBindSelected;
        riveWidget.ViewModelInstanceName = "My Instance";

        // Load the Rive file after setting the binding mode
        riveWidget.Load(riveFile, artboardName, stateMachineName);

        ...
        // Access the current instance that was auto-bound
        ViewModelInstance boundInstance = riveWidget.StateMachine.ViewModelInstance;


        ```
    </Tab>
     <Tab title="React Native">
        The default value for the `dataBinding` prop is `AutoBind(false)`, which means auto-binding is disabled by default.

        To enable auto-binding, set the `dataBinding` prop to `AutoBind(true)`.

        ```typescript {7}
        const [setRiveRef, riveRef] = useRive();

        return (
            <Rive
                ref={setRiveRef}
                autoplay={true}
                dataBinding={AutoBind(true)} // default: `AutoBind(false)`
                stateMachineName={'State Machine 1'}
                resourceName={'rewards'}
            />
        );
        ```
    </Tab>
</Tabs>

# Properties

A property is a value that can be read, set, or observed on a view model instance. Properties can be of the following types:

| Type                   | Supported             |
|------------------------|-----------------------|
| Floating point numbers | âœ…                     |
| Booleans               | âœ…                     |
| Triggers               | âœ…                     |
| Strings                | âœ…                     |
| Enumerations           | âœ…                     |
| Colors                 | âœ…                     |
| Nesting                | âœ…                     |
| Lists                  | ðŸš§ Coming soon         |
| Images                 | ðŸš§ Coming soon         |

Property descriptors can be inspected on a view model to discover at runtime which are available. These are not the mutable properties themselves though - once again those are on instances. These descriptors have a type and name.

<Tabs>
    <Tab title="Web">
    ```typescript
    // A list of properties on a view model (ViewModel)
    const properties = viewModel.properties;
    console.log(properties);
    ```
    </Tab>
    <Tab title="React">
    ```typescript
    // Access properties from the view model returned by useViewModel
    const viewModel = useViewModel(rive);
    console.log(viewModel?.properties);
    ```
    </Tab>
    <Tab title="Apple">
        ```swift
        let riveViewModel = RiveViewModel(...)
        let viewModel = riveViewModel.riveModel!.file.viewModelNamed(...)!
        for property in viewModel.properties {
            print(property.type) // String, number, boolean, etc
            print(property.name) // The name of the property within the view model
        }
        ```
    </Tab>
    <Tab title="Android">
        ```kotlin
        val vm = view.controller.file?.getViewModelByName("My View Model")!!

        // A list of properties
        val properties = vm.properties
        assertContains(
            properties,
            ViewModel.Property(ViewModel.PropertyDataType.NUMBER, "My Number Property")
        )
        ```
    </Tab>
    <Tab title="Flutter">
        ```dart
        // Accesss on a ViewModel object
        print("Properties: ${viewModel.properties}");

        // Access on a ViewModelInstance object
        print("Properties: ${viewModelInstance.properties}");
        ```
    </Tab>
    <Tab title="Unity">
        ```csharp
        var vm = riveWidget.File.GetViewModelByName("My View Model");

        // A list of properties
        var properties = vm.Properties;
        foreach (var prop in properties)
        {
            Debug.Log($"Property: {prop.Name}, Type: {prop.Type}");
        }
        ```
    </Tab>
     <Tab title="React Native">
        <Warning>
        The properties API is not yet available in React Native.
        </Warning>
    </Tab>
</Tabs>

### Nested Property Paths

View models can have properties of type view model, allowing for arbitrary nesting. We could chain property calls on each instance starting from the root until we get to the property of interest. Alternatively we can do this through a path parameter, which is similar to a URI in that it is a forward slash delimited list of property names ending in the name of the property of interest.

<Tabs>
    <Tab title="Web">
    ```typescript
    const rive = new rive.Rive({
        autoBind: true,
        onLoad: () => {
            // Access the current instance that was auto-bound
            let vmi = rive.viewModelInstance;

            const nestedNumberByChain = vmi
                .viewModel("My Nested View Model")
                .viewModel("My Second Nested VM")
                .number("My Nested Number");

            const nestedNumberByPath = vmi.number("My Nested View Model/My Second Nested VM/My Nested Number");
        }
    });
    ```
    </Tab>
    <Tab title="React">
        Access nested properties by providing the full path (separated by `/`) as the first argument to the property hooks.

        ```typescript
        import { useViewModelInstanceString, useViewModelInstanceNumber } from '@rive-app/react-webgl2';

        // Accessing 'settings/theme/name' (String)
        const { value: themeName, setValue: setThemeName } = useViewModelInstanceString(
            'settings/theme/name',
            viewModelInstance
        );

        // Accessing 'settings/volume' (Number)
        const { value: volume, setValue: setVolume } = useViewModelInstanceNumber(
            'settings/volume',
            viewModelInstance
        );

        console.log('Current theme:', themeName);
        // setThemeName('Dark Mode');
        // setVolume(80);
        ```
    </Tab>
    <Tab title="Apple">
        ```swift
        let riveViewModel = RiveViewModel(...)
        let instance = riveViewModel.riveModel!.riveFile.viewModelNamed("...")!.createDefaultInstance()!

        let nestedNumberByChain = instance
                                    .viewModelInstanceProperty(fromPath: "Nested View Model")
                                    .viewModelInstanceProperty(fromPath: "Another Nested View Model")
                                    .numberProperty(fromPath: "Number")

        let nestedNumberByPath = instance.numberProperty(fromPath: "Nested View Model/Another Nested View Model/Number")
        ```
    </Tab>
    <Tab title="Android">
        ```kotlin
        val vm = view.controller.file?.getViewModelByName("My View Model")!!
        val vmi = vm.createInstanceFromName("My Instance")

        val nestedNumberByChain = vmi
            .getInstanceProperty("My Nested View Model")
            .getInstanceProperty("My Second Nested VM")
            .getNumberProperty("My Nested Number")

        val nestedNumberByPath = vmi
            .getNumberProperty("My Nested View Model/My Second Nested VM/My Nested Number")
        ```
    </Tab>
    <Tab title="Flutter">
        ```dart
        final vm = file.viewModelByName("My View Model")!;
        final vmi = vm.createInstanceByName("My Instance")!;

        final nestedNumberByChain = vmi
            .viewModel("My Nested View Model")!
            .viewModel("My Second Nested VM")!
            .number("My Nested Number");

        final nestedNumberByPath = vmi.number("My Nested View Model/My Second Nested VM/My Nested Number");
        ```
    </Tab>
    <Tab title="Unity">
        ```csharp
        if (riveWidget.Status == WidgetStatus.Loaded)
        {
            var viewModelInstance = riveWidget.StateMachine.ViewModelInstance;

            // Accessing nested view models using chaining
            var nestedNumberByChain = viewModelInstance
                .GetViewModelInstanceProperty("My Nested View Model")
                .GetViewModelInstanceProperty("My Second Nested VM")
                .GetNumberProperty("My Nested Number");

            // Accessing nested properties using path notation
            var nestedNumberByPath = viewModelInstance
                .GetNumberProperty("My Nested View Model/My Second Nested VM/My Nested Number");


        }
        ```
    </Tab>
     <Tab title="React Native">
        <Warning>
        React Native does not support accessing nested properties using the chain notation.
        But you can access nested properties using the path notation.
        </Warning>
        ```js
        const [setRiveRef, riveRef] = useRive();
        const nestedNumberByPath = useRiveNumber(riveRef, 'My Nested View Model/My Second Nested VM/My Nested Number');
        useEffect(() => {
            if (nestedNumberByPath) {
                nestedNumberByPath.setValue(10);
            }
        }, [nestedNumberByPath]);
        ```
    </Tab>
</Tabs>

### Mutable Properties

View model instances have mutable properties. References to these properties can be retrieved by name. They have get, set, and observe operations. Getting or observing the value will retrieve the latest value set on that properties binding, as of the last state machine or artboard advance. Setting the value will update the value and all of its bound elements.

<Note>Trigger properties do not have a get operation - only set and observe.</Note>

<Note>After setting a property's value, the changes will not apply to their bound elements until the state machine or artboard advances.</Note>

<Tabs>
    <Tab title="Web">
    ```typescript
    const rive = new rive.Rive({
        autoBind: true,
        onLoad: () => {
            // Access the current instance that was auto-bound
            let vmi = rive.viewModelInstance;

            // Booleans
            const booleanProperty = vmi.boolean("My Boolean Property");
            const booleanValue = booleanProperty.value;
            booleanProperty.value = true;

            // Strings
            const stringProperty = vmi.string("My String Property");
            const stringValue = stringProperty.value;
            stringProperty.value = "Hello, Rive!";

            // Numbers
            const numberProperty = vmi.number("My Number Property");
            const numberValue = numberProperty.value;
            numberProperty.value = 10;

            // Colors
            const colorProperty = vmi.color("My Color Property");
            const colorValue = colorProperty.value;
            colorProperty.value = 0xFF000000; // Set color to black with 100% opacity

            // Other ways to set color
            colorProperty.rgb(255, 0, 0); // Set RGB to red
            colorProperty.rbga(255, 0, 0, 128); // Set RGBA to red with 50% opacity
            colorProperty.argba(128, 255, 0, 0); // Set RGBA to red with 50% opacity
            colorProperty.opacity(0.5); // Set opacity to 50%

            // Triggers
            const triggerProperty = vmi.trigger("My Trigger Property");
            triggerProperty.trigger();

            // Enumerations
            const enumProperty = vmi.enum("My Enum Property");
            const enumValue = enumProperty.value;
            enumProperty.value = "Option1";
        }
    });
    ```
    </Tab>
    <Tab title="React">
        Use the specific hook for a given property type to get and set property values.

        - `useViewModelInstanceBoolean`: Read/write boolean properties
        - `useViewModelInstanceString`: Read/write string properties
        - `useViewModelInstanceNumber`: Read/write number properties
        - `useViewModelInstanceColor`: Read/write color properties with additional RGB/alpha methods
        - `useViewModelInstanceEnum`: Read/write enum properties with available values
        - `useViewModelInstanceTrigger`: Fire trigger events with optional callbacks

        These hooks return the current `value` and a function to update it (`setValue`, `setRgb`, `trigger`). The `value` will be null if the property is not found or if the hook is provided with an invalid viewModelInstance.


        ```typescript
        import {
            useViewModelInstanceBoolean,
            useViewModelInstanceString,
            useViewModelInstanceNumber,
            useViewModelInstanceEnum,
            useViewModelInstanceColor,
            useViewModelInstanceTrigger
        } from '@rive-app/react-webgl2';

        // Assuming viewModelInstance is obtained via useViewModelInstance or rive.viewModelInstance

        // Boolean
        const { value: isActive, setValue: setIsActive } = useViewModelInstanceBoolean(
            'isToggleOn', // Property path
            viewModelInstance
        );
        // Set: setIsActive(true);

        // String
        const { value: userName, setValue: setUserName } = useViewModelInstanceString(
            'user/name', // Property path
            viewModelInstance
        );
        // Set: setUserName('Rive');

        // Number
        const { value: score, setValue: setScore } = useViewModelInstanceNumber(
            'levelScore', // Property path
            viewModelInstance
        );
        // Set: setScore(100);

        // Enum
        const { value: status, setValue: setStatus, values: statusOptions } = useViewModelInstanceEnum(
            'appStatus', // Property path
            viewModelInstance
        );
        // Set: setStatus('loading');
        // Get available options: statusOptions is an array like ['idle', 'loading', 'error']

        // Color
        const {
            value: themeColor, // Raw number value like -3267805
            setRgb: setThemeColorRgb, // Set RGB components (0-255 values)
            setAlpha: setThemeColorAlpha, // Set alpha component (0-255)
            setOpacity: setThemeColorOpacity, // Set opacity (0.0-1.0)
            setRgba: setThemeColorRgba, // Set all components at once
            setValue: setThemeColorValue // Set raw color value
        } = useViewModelInstanceColor(
            'ui/themeColor', // Property path
            viewModelInstance
        );
        // Set RGB: setThemeColorRgb(0, 128, 255); // Set to a blue color
        // Set Alpha: setThemeColorAlpha(128); // Set to 50% opacity
        // Set Opacity: setThemeColorOpacity(0.5); // Set to 50% opacity
        // Set RGBA: setThemeColorRgba(0, 128, 255, 255); // Blue with full opacity
        // Set Value: setThemeColorValue(-3267805); // Set using raw color value

        // Trigger (No value, just a trigger function)
        const { trigger: playEffect } = useViewModelInstanceTrigger(
            'playButtonEffect', // Property path
            viewModelInstance,
            {
                // Optional callback to be called when the trigger is fired
                onTrigger: () => {
                    console.log('Trigger Fired!');
                }
            }
        );
        // Trigger: playEffect();
        ```
        The `value` returned by each hook will update automatically when the property changes in the Rive graphic.
    </Tab>
    <Tab title="Apple">
        ```swift
        let riveViewModel = RiveViewModel(...)
        let instance = riveViewModel.riveModel!.riveFile.viewModelNamed("...")!.createDefaultInstance()!

        // Strings
        let stringProperty = instance.stringProperty(fromPath: "...")!
        // Updating its value
        stringProperty.value = "Hello, Rive"
        // Get its value
        print(stringProperty.value)

        // You can also set and get values without storing a strong reference
        instance.stringProperty(fromPath: "...").value = "Hello again, Rive"

        // Numbers
        let numberProperty = instance.numberProperty(fromPath: "...")!
        // Updating its value
        numberProperty.value = 1337
        // Get its value
        print(numberProperty.value)

        // You can also set and get values without storing a strong reference
        instance.numberProperty(fromPath: "...").value = 1337

        // Booleans
        let booleanProperty = instance.booleanProperty(fromPath: "...")!
        // Updating its value
        booleanProperty.value = true
        // Get its value
        print(booleanProperty.value)

        // You can also set and get values without storing a strong reference
        instance.booleanProperty(fromPath: "...").value = true

        // Colors
        let colorProperty = instance.colorProperty(fromPath: "...")!
        // Updating its value, which is a UIColor/NSColor, so all static helpers apply.
        colorProperty.value = .red
        // Get its value
        print(colorProperty.value)

        // You can also set and get values without storing a strong reference
        instance.colorProperty(fromPath: "...").value = .red

        // Enums
        let enumProperty = instance.enumProperty(fromPath: "...")!
        // Updating its value
        enumProperty.value = "Foo"
        // Get its value
        print(enumProperty.value)
        // Print all possible values
        print(enumProperty.values)

        // You can also set and get values without storing a strong reference
        instance.enumProperty(fromPath: "...").value = "Foo"

        // Trigger
        let triggerProperty = instance.triggerProperty(fromPath: "...")!
        // Fire the trigger
        triggerProperty.trigger()
        ```
    </Tab>
    <Tab title="Android">
        ```kotlin
        val vm = view.controller.file?.getViewModelByName("My View Model")!!
        val vmi = vm.createInstanceFromName("My Instance")

        val numberProperty = vmi.getNumberProperty("My Number Property")
        // Get
        val numberValue = numberProperty.value
        // Set
        numberProperty.value = 10f
        ```
    </Tab>
    <Tab title="Flutter">
        ```dart
        final vm = file.defaultArtboardViewModel(artboard)!;
        final vmi = vm.createDefaultInstance()!;

        final numberProperty = vmi.number("My Number Property")!;
        // Get
        final numberValue = numberProperty.value;

        // Set
        numberProperty.value = 10;

        // Observe
        void onNumberChange(double value) {
            print("Number changed to: $value");
        }
        numberProperty.addListener(onNumberChange);

        // Remove listener when done
        numberProperty.removeListener(onNumberChange);

        // Alternatively, clear all listeners
        numberProperty.clearListeners();

        // Dispose of the property to clear up resources when you're no longer using it
        // This will call `clearListeners()` internally.
        numberProperty.dispose();
        ```
    </Tab>
    <Tab title="Unity">
        ```csharp
        private void OnEnable()
        {
            riveWidget.OnWidgetStatusChanged += HandleWidgetStatusChanged;
        }

        private void OnDisable()
        {
            riveWidget.OnWidgetStatusChanged -= HandleWidgetStatusChanged;
        }

        private void HandleWidgetStatusChanged()
        {
            // Check if the widget is loaded before accessing the view model instance
            if (riveWidget.Status == WidgetStatus.Loaded)
            {
                ViewModelInstance viewModelInstance = riveWidget.StateMachine.ViewModelInstance;

             //==========================================================================
            // STRING PROPERTIES
            //==========================================================================
                ViewModelInstanceStringProperty stringProperty = viewModelInstance.GetStringProperty("title");
                Debug.Log($"String value: {stringProperty.Value}");
                stringProperty.Value = "New Text";

            //==========================================================================
            // NUMBER PROPERTIES
            //==========================================================================
                ViewModelInstanceNumberProperty numberProperty = viewModelInstance.GetNumberProperty("count");
                Debug.Log($"Number value: {numberProperty.Value}");
                numberProperty.Value = 42.5f;

            //==========================================================================
            // BOOLEAN PROPERTIES
            //==========================================================================
                ViewModelInstanceBooleanProperty boolProperty = viewModelInstance.GetBooleanProperty("isActive");
                Debug.Log($"Boolean value: {boolProperty.Value}");
                boolProperty.Value = true;

            //==========================================================================
            // COLOR PROPERTIES
            //==========================================================================
                ViewModelInstanceColorProperty colorProperty = viewModelInstance.GetColorProperty("backgroundColor");
                // Using Unity Color (float values 0-1)
                Color currentColor = colorProperty.Value;
                colorProperty.Value = new UnityEngine.Color(1, 0, 0, 1); // Red color
                // Or using Color32 (byte values 0-255)
                Color32 currentColor32 = colorProperty.Value32;
                colorProperty.Value32 = new Color32(0, 255, 0, 255); // Green color

            //==========================================================================
            // ENUM PROPERTIES
            //==========================================================================
                ViewModelInstanceEnumProperty enumProperty = viewModelInstance.GetEnumProperty("category");
                Debug.Log($"Enum current value: {enumProperty.Value}");
                Debug.Log($"Enum available values: {string.Join(", ", enumProperty.EnumValues)}");
                enumProperty.Value = "option_name";

            //==========================================================================
            // TRIGGER PROPERTIES
            //==========================================================================
                ViewModelInstanceTriggerProperty triggerProperty = viewModelInstance.GetTriggerProperty("onSubmit");
                triggerProperty.Trigger(); // Fire the trigger
            }
        }
        ```
    </Tab>
     <Tab title="React Native">
        There following data binding methods are exposed on the `RiveRef` object.

        ```typescript
        setBoolean: (path: string, value: boolean) => void;
        setString: (path: string, value: string) => void;
        setNumber: (path: string, value: number) => void;
        setColor: (path: string, color: RiveRGBA | string) => void;
        setEnum: (path: string, value: string) => void;
        trigger: (path: string) => void;
        ```

        <Note>
        The color property can be set using either a `RiveRGBA` object or a hex string. The hex string should be in the format
        `#RRGGBBAA`, where `RR`, `GG`, `BB`, and `AA` are two-digit hexadecimal values representing the red, green, blue, and
        alpha channels, respectively.
        ```js
        type RiveRGBA = { r: number; g: number; b: number; a: number };
        ```
        </Note>

        Example usage:
        ```typescript
        const [setRiveRef, riveRef] = useRive();
        const setBoolean = () => {
            if (riveRef) {
                riveRef.setBoolean('My Boolean Property', true);
            }
        };
        const setString = () => {
            if (riveRef) {
                riveRef.current.setString('My String Property', 'Hello, Rive');
            }
        };
        const setNumber = () => {
            if (riveRef) {
                riveRef.current.setNumber('My Number Property', 10);
            }
        };
        const setColor = () => {
            if (riveRef) {
                riveRef.setColor('My Color Property', { r: 255, g: 0, b: 0, a: 1 });
                // or
                riveRef.setColor('My Color Property', '#00FF00FF');
            }
        };
        const setEnum = () => {
            if (riveRef) {
                riveRef.setEnum('My Enum Property', 'Option 1');
            }
        };
        const trigger = () => {
            if (riveRef) {
                riveRef.trigger('My Trigger Property');
            }
        };
        ```
    </Tab>

</Tabs>

#### Observability

You can observe changes over time to property values, either by using listeners or a platform equivalent method. Once observed, you will be notified when the property changes are applied by a state machine advance, whether that is a new value that has been explicitly set or if the value was updated as a result of a binding. Observing trigger properties is an alternative method to receive events from the editor, as compared to [Rive Events](/runtimes/rive-events).

<Tabs>
    <Tab title="Web">
    Adding an observer to a property is done by calling the `on` method on the property.
    ```typescript
    public on(callback: EventCallback)
    ```

    The observer can be removed by calling the `off` method on the property and passing the callback function. Alternatively, you can call `off()` without any arguments to remove all observers.
    ```typescript
    public off(callback?: EventCallback)
    ```
    Example:
    ```typescript
    const rive = new rive.Rive({
        autoBind: true,
        onLoad: () => {
            // Access the current instance that was auto-bound
            let vmi = rive.viewModelInstance;
            const numberProperty = vmi.number("My Number Property");
            // Observe
            numberProperty.on((event) => {
                console.log(event.data);
            });
            // Remove all listener when done
            numberProperty.off();
        }
    });
    ```
    </Tab>
    <Tab title="React">
        The React hooks handle observability automatically. When a property's value changes within the Rive instance (either because you set it via a hook or due to an internal binding), the `value` returned by the corresponding hook (e.g., `useViewModelInstanceString`) updates. This state change triggers a re-render of your React component, allowing you to react to the new value.

        For Triggers, you can provide an `onTrigger` callback directly to the `useViewModelInstanceTrigger` hook, which fires when the trigger is activated in the Rive instance.

        ```typescript
        import { useViewModelInstanceTrigger } from '@rive-app/react-webgl2';

        // Assuming viewModelInstance is available
        const { trigger } = useViewModelInstanceTrigger(
            'showPopup',
            viewModelInstance,
            {
                onTrigger: () => {
                    console.log('Show Popup Trigger Fired!');
                    // Show your popup UI
                }
            }
        );
        ```
    </Tab>
    <Tab title="Apple">
        ```swift
        let riveViewModel = RiveViewModel(...)
        let instance = riveViewModel.riveModel!.riveFile.viewModelNamed("...")!.createDefaultInstance()!

        // Get the string property
        let stringProperty = instance.stringProperty(fromPath: "...")!

        // Add a listener
        let listener = stringProperty.addListener { newValue in
            print(newValue)
        }

        // Remove a listener, where listener is the return value of addListener
        stringProperty.removeListener(listener)

        // Trigger properties can also be listened to for when they are triggered
        instance.triggerProperty(fromPath: "...")!.addListener {
            print("Triggered!")
        }
        ```
    </Tab>
    <Tab title="Android">
        ```kotlin
        val vm = view.controller.file?.getViewModelByName("My View Model")!!
        val vmi = vm.createInstanceFromName("My Instance")

        val numberProperty = vmi.getNumberProperty("My Number Property")
        // Observe
        lifecycleScope.launch {
            numberProperty.collect { value ->
                Log.i("MyActivity", "Value: $value")
            }
        }
        // Or collect in Compose
        val numberValue by numberProperty.collectAsState()
        ```
    </Tab>
    <Tab title="Flutter">
        ```dart
        final vm = file.defaultArtboardViewModel(artboard)!;
        final vmi = vm.createDefaultInstance()!;

        final numberProperty = vmi.number("My Number Property")!;
        // Get
        final numberValue = numberProperty.value;

        // Set
        numberProperty.value = 10;

        // Observe
        void onNumberChange(double value) {
            print("Number changed to: $value");
        }
        numberProperty.addListener(onNumberChange);

        // Remove listener when done
        numberProperty.removeListener(onNumberChange);

        // Alternatively, clear all listeners
        numberProperty.clearListeners();

        // Dispose of the property to clear up resources when you're no longer using it
        // This will call `clearListeners()` internally.
        numberProperty.dispose();
        ```
    </Tab>
    <Tab title="Unity">
        ```csharp
        private ViewModelInstanceNumberProperty numberProperty;
        private ViewModelInstanceStringProperty stringProperty;
        private ViewModelInstanceBooleanProperty boolProperty;
        private ViewModelInstanceColorProperty colorProperty;
        private ViewModelInstanceEnumProperty enumProperty;
        private ViewModelInstanceTriggerProperty triggerProperty;

        private void OnEnable()
        {
            riveWidget.OnWidgetStatusChanged += HandleWidgetStatusChanged;
        }

        private void OnDisable()
        {
            riveWidget.OnWidgetStatusChanged -= HandleWidgetStatusChanged;
        }

        private void HandleWidgetStatusChanged()
        {
            if (riveWidget.Status == WidgetStatus.Loaded)
            {
                ViewModelInstance viewModelInstance = riveWidget.StateMachine.ViewModelInstance;

                // Add listeners to properties
                numberProperty = viewModelInstance.GetNumberProperty("count");
                numberProperty.OnValueChanged += OnNumberPropertyChanged;

                stringProperty = viewModelInstance.GetStringProperty("title");
                stringProperty.OnValueChanged += OnStringPropertyChanged;

                boolProperty = viewModelInstance.GetBooleanProperty("isActive");
                boolProperty.OnValueChanged += OnBoolPropertyChanged;

                colorProperty = viewModelInstance.GetColorProperty("backgroundColor");
                colorProperty.OnValueChanged += OnColorPropertyChanged;

                enumProperty = viewModelInstance.GetEnumProperty("category");
                enumProperty.OnValueChanged += OnEnumPropertyChanged;

                triggerProperty = viewModelInstance.GetTriggerProperty("onSubmit");
                triggerProperty.OnTriggered += OnTriggerPropertyFired;


            }
        }

        private void OnNumberPropertyChanged(float newValue)
        {
            Debug.Log($"Number changed to: {newValue}");
        }

        private void OnStringPropertyChanged(string newValue)
        {
            Debug.Log($"String changed to: {newValue}");
        }

        private void OnBoolPropertyChanged(bool newValue)
        {
            Debug.Log($"Boolean changed to: {newValue}");
        }

        private void OnColorPropertyChanged(UnityEngine.Color newValue)
        {
            Debug.Log($"Color changed to: {ColorUtility.ToHtmlStringRGBA(newValue)}");
        }

        private void OnEnumPropertyChanged(string newValue)
        {
            Debug.Log($"Enum changed to: {newValue}");
        }

        private void OnTriggerPropertyFired()
        {
            Debug.Log("Trigger fired!");
        }

        private void OnDestroy()
        {
            // You should remove listeners when no longer needed,
            numberProperty.OnValueChanged -= OnNumberPropertyChanged;
            stringProperty.OnValueChanged -= OnStringPropertyChanged;
            boolProperty.OnValueChanged -= OnBoolPropertyChanged;
            colorProperty.OnValueChanged -= OnColorPropertyChanged;
            enumProperty.OnValueChanged -= OnEnumPropertyChanged;
            triggerProperty.OnTriggered -= OnTriggerPropertyFired;
        }
        ```
    </Tab>
     <Tab title="React Native">
        Values are observed through hooks.

        ```typescript
        const [setRiveRef, riveRef] = useRive();
        const [boolValue, setBoolValue] = useRiveBoolean(riveRef, 'My Boolean Property');
        const [stringValue, setStringValue] = useRiveString(riveRef, 'My String Property');
        const [numberValue, setNumberValue] = useRiveNumber(riveRef, 'My Number Property');
        const [colorValue, setColorValue] = useRiveColor(riveRef, 'My Color Property');
        const [enumValue, setEnumValue] = useRiveEnum(riveRef, 'My Enum Property');
        const triggerButton = useRiveTrigger(riveRef, 'My Trigger Property', () => {
            console.log('Trigger fired');
        });

        useEffect(() => {
            if (numberValue !== undefined) {
            console.log('numberValue changed:', numberValue);
            }
        }, [numberValue]);

        const handleButtonPress = () => {
            if (trigger) {
                trigger();
            }
        };
        ```
        <Note>
        The `useRiveTrigger` hook does not return a value, but instead takes a callback function as its third argument.
        This callback will be executed when the trigger is fired.
        </Note>
    </Tab>
</Tabs>

### Images

<EarlyAccessFeature featureName="Image property support"/>

Image properties let you set and replace raster images at runtime, with each instance of the image managed independently. For example, you could build an avatar creator and dynamically update features â€” like swapping out a hat â€” by setting a view model's image property.

<Tabs>
    <Tab title="Apple">
        ```swift
        // Create a RiveImageAsset from data
        let data = Data(...)
        var image = RiveImageAsset(data: data)! // This can return nil if the data is not a valid image

        // Or, create a RiveImageAsset from a UIImage
        image = RiveImageAsset(image: UIImage(named: "my_image")!, format: .png)! // This can return nil if the image is not a valid jpg or png image

        let imageProperty = viewModelInstance.imageProperty(fromPath: "image")!

        // Once you have your data binding view model instance, you can set the image property value
        imageProperty.setValue(image)

        // You can also pass nil to clear the image
        imageProperty.setValue(nil)
        ```
    </Tab>
</Tabs>

### Lists

<EarlyAccessFeature featureName="List property support"/>
List properties let you manage a dynamic set of view model instances at runtime. For example, you can build a TODO app where users can add and remove tasks in a scrollable Layout.

A single list property can include different view model types, with each view model tied to its own Nested Artboard, making it easy to populate a list with a varity of Nested Artboards.

With list properties, you can:
- Add a new view model instance (optionally at an index)
- Remove an existing view model instance (optionally by index)
- Swap two view model instances by index
- Get the size of a list

For more information on list properties, see the [Data Binding List Property](/editor/data-binding/lists#view-model-list-property) editor documentation.

<Tabs>
    <Tab title="Apple">
    ```swift
    let listProperty = viewModelInstance.listProperty(fromPath: "list")!

    // Create a new view model instance and add it to the end of the list
    let firstInstance = viewModel.createInstanceByName("First Instance")!
    listProperty.add(firstInstance)
    
    // Create a new view model instance and add it to the beginning of the list
    let secondInstance = myViewModel.createInstanceByName("Second Instance")!
    listProperty.add(secondInstance, atIndex: 0)

    // Swap the first and second instances
    listProperty.swapInstance(atIndex: 0, withInstanceAtIndex: 1)

    // Remove both instances
    listProperty.removeInstance(secondInstance)
    listProperty.removeInstance(atIndex: 0)

    // Get and print the size of the list
    print(listProperty.size) // Prints 0
    ```
    </Tab>
</Tabs>


### Enums

Enums properties come in two flavors: system and user-defined. In practice, you will not need to worry about the distinction, but just be aware that system enums are available in any Rive file that binds to an editor-defined enum set, representing options from the editor's dropdowns, where user-defined enums are those defined by a designer in the editor.

Enums are string typed. The Rive file contains a list of enums. Each enum in turn has a name and a list of strings.

<Tabs>
    <Tab title="Web">
    ```typescript
    const rive = new rive.Rive({
        onLoad: () => {
            const enums = rive.enums();

            console.log(enums);
        }
    });
    ```
    </Tab>
    <Tab title="React">
        ```typescript
        const { rive } = useRive({
            src: 'your_file.riv',
            artboard: 'MyArtboard',
            stateMachine: 'MyStateMachine',
            autoBind: true
            // ... other options
        });
        const enums = rive?.enums();
        console.log(enums);
        ```
    </Tab>
    <Tab title="Android">
        ```kotlin
        val enums = view.controller.file?.enums!!

        val firstEnumName = enums[0].name
        val firstEnumFirstValue = enums[0].values[0]
        ```
    </Tab>
    <Tab title="Flutter">
        ```dart
        // Accesss on a File object
        print("Data enums: ${file.enums}");
        ```
    </Tab>
    <Tab title="Unity">
        ```csharp

            var viewModelInstance = riveWidget.StateMachine.ViewModelInstance;

            // Accessing enums from the file
            var enums = riveWidget.File.ViewModelEnums;
            foreach (var enumType in enums)
            {
                Debug.Log($"Enum: {enumType.Name}");
                foreach (var value in enumType.Values)
                {
                    Debug.Log($" - Value: {value}");
                }
            }

            ...
            // Using enum properties
            var enumProperty = viewModelInstance.GetEnumProperty("category");
            Debug.Log($"Current value: {enumProperty.Value}");
            Debug.Log($"Available values: {string.Join(", ", enumProperty.EnumValues)}");
            enumProperty.Value = enumProperty.EnumValues[0]; // Set to first value

        ```
    </Tab>
     <Tab title="React Native">
        <Warning>
        Retrieving the list of enums on the file is not yet available in React Native.
        </Warning>
    </Tab>
</Tabs>

# Examples
<Tabs>
    <Tab title="Web">
    See [this video](https://youtu.be/G6IWCZ1IG10?t=1243) for an intro to data binding using the Web runtime along with this [CodeSandbox example](https://codesandbox.io/p/sandbox/rive-data-binding-quick-start-js-6v2ltn?file=%2Fsrc%2Findex.mjs%3A25%2C35).

    <YouTube id="G6IWCZ1IG10" timestamp="1243" />
    </Tab>
    <Tab title="React">
      See the `DataBinding` story in the [Rive React repo](https://github.com/rive-app/rive-react) for a demo.
    </Tab>
    <Tab title="Apple">
        See the [Data Binding view](https://github.com/rive-app/rive-ios/blob/main/Example-iOS/Source/Examples/SwiftUI/DataBindingView.swift) in the Example app for a demo.
    </Tab>
    <Tab title="Flutter">
        See the `examples/data_binding.dart` file in the example app on [Pub](https://pub.dev/packages/rive_native) for a demo.

        ```bash
        dart pub unpack rive_native # Unpack the package source code and example app
        cd rive_native/example      # Navigate to the example folder
        flutter create .            # Create the platform folders
        flutter pub get             # Fetch dependencies
        flutter run                 # Run the example app
        ```
    </Tab>
     <Tab title="React Native">
        See the [Data Binding view](https://github.com/rive-app/rive-react-native/blob/main/example/app/(examples)/DataBinding.tsx) in the Example app for a demo.
    </Tab>
</Tabs>
