---
title: "Data Binding"
description: "Connect your code to bound editor elements using View Models"
---

import { YouTube } from "/snippets/youtube.mdx";
import { Demos } from "/snippets/demos.jsx";
import { Apple } from "/snippets/constants.mdx"

# Overview

Before engaging with the runtime data binding APIs, it is important to familiarize yourself with the core concepts presented in the [Overview](/editor/data-binding/overview).

<Card
  title="Data Binding Concepts"
  icon={
    <svg
      xmlns="http://www.w3.org/2000/svg"
      height="100%"
      fill="none"
      viewBox="0 0 16 16"
      class="size-4 text-gray-500/80 dark:text-gray-400"
      aria-hidden="true"
    >
      <path
        fill="currentColor"
        d="M7.31 7.111 2.406 5.15l4.61-1.844.328-.126a2.3 2.3 0 0 1 1.647 0l.33.126L13.93 5.15 9.024 7.112c-.55.22-1.163.22-1.712 0"
      ></path>
      <path
        stroke="currentColor"
        stroke-linecap="round"
        stroke-linejoin="round"
        d="m2.405 10.911 4.906 1.963c.55.22 1.162.22 1.712 0l4.906-1.963M2.405 8.031 7.31 9.992c.55.22 1.162.22 1.712 0l4.906-1.963M2.405 5.15 7.31 7.111c.55.22 1.162.22 1.712 0l4.906-1.962-4.61-1.844-.329-.126a2.3 2.3 0 0 0-1.647 0l-.329.126z"
      ></path>
    </svg>
  }
  href="/editor/data-binding/overview"
>
  An overview of core data binding concepts.
</Card>
<br />

<Demos examples={["dataBindingQuickStart"]} />

# View Models

View models describe a set of properties, but cannot themselves be used to get or set values - that is the role of [view model instances](#view-model-instances).

To begin, we need to get a reference to a particular view model. This can be done either by index, by name, or the default for a given artboard, and is done from the Rive file. The default option refers to the view model assigned to an artboard by the dropdown in the editor.

<Tabs>
  <Tab title="Web">
    Access a View Model from the created Rive object in the `onLoad` callback:

    ```typescript
    const rive = new rive.Rive({
        onLoad: () => {
            // The Rive object is now loaded and ready to use.
        }
    });
    ```

    Once Rive is loaded, you can access the view models using the following methods:

    ```typescript
    // Get reference by name
    const namedVM = rive.viewModelByName("My View Model");

    // Get reference by index
    for (let i = 0; i < rive.viewModelCount; i++) {
        const indexedVM = rive.viewModelByIndex(i);
    }

    // Get reference to the default view model
    const defaultVM = rive.defaultViewModel();
    ```

    Alternatively, if you have access to the underlying Rive File object you can access the above methods on the file.

    ```typescript
    const namedVM = file.viewModelByName("My View Model");
    const indexedVM = file.viewModelByIndex(0);
    const defaultVM = file.defaultArtboardViewModel(artboard);
    ```

  </Tab>
  <Tab title="React">
    Use the `useViewModel` hook to get a reference to a view model. You need to pass the `rive` object obtained from `useRive`.

    ```typescript
    import { useRive, useViewModel } from '@rive-app/react-webgl2';

    const { rive, RiveComponent } = useRive({
        src: 'your_file.riv',
        // ... other options
    });

    // Option 1: Get the default ViewModel for the artboard
    const defaultViewModel = useViewModel(rive);

    // Option 2: Get the default ViewModel explicitly
    const defaultViewModelExplicit = useViewModel(rive, { useDefault: true });

    // Option 3: Get a ViewModel by its name
    const namedViewModel = useViewModel(rive, { name: 'MyViewModelName' });
    ```
  </Tab>
  <Tab title="Apple">
    <Tabs>
        <Tab title={Apple.currentRuntimeName}>
        View models are not their own type; rather, they are a source when creating a view model instance from a `File`.

        You can define the source of a view model via the `ViewModelSource` type.

        ```swift
        case artboardDefault(Artboard) // References the default view model for an Artboard
        case name(String) // References a view model from a file by name
        ```

        These sources are used in conjunction with getting a view model instance. See [View Model Instances](#view-model-instances) for more information.
        </Tab>
        <Tab title={Apple.legacyRuntimeName}>
        ```swift
        let riveViewModel = RiveViewModel(...)
        let file = riveViewModel.riveModel!.riveFile

        // Data binding view model by name
        let viewModelByName = file.viewModelNamed("...")

        // Data binding view model by index
        for index in 0..<file.viewModelCount {
            let viewModelByIndex = file.viewModel(at: index)
        }

        // Default data binding view model for an artboard
        let artboard = riveViewModel.riveModel!.artboard
        let viewModelForArtboard = file.viewModel(for: artboard)
        ```
        </Tab>
    </Tabs>
  </Tab>

  <Tab title="Android">
    <Tabs>
      <Tab title="Compose">
        Unlike other runtimes, view models do not exist as a separate object in the Compose API. Instead, they are represented as a `ViewModelSource` sealed class that forms half of a builder pattern used to create view model instances. See [View Model Instances](#view-model-instances) for details on the other half - creating instances.

        ```kotlin
        // Named source
        val vmSource = ViewModelSource.Named("My View Model")
        // Default for artboard source
        val vmSource = ViewModelSource.DefaultForArtboard(artboard)
        ```
      </Tab>
      <Tab title="Legacy">
        ```kotlin
        // `view` of type RiveAnimationView
        view.setRiveResource(R.raw.my_rive_file)
        val file = view.controller.file!!

        // Get reference by name
        val vm = file.getViewModelByName("My View Model")

        // Get reference by index
        for (i in 0 until file.viewModelCount) {
            val indexedVM = file.getViewModelByIndex(i)
        }

        // Get reference to the default view model
        val defaultVM = file.defaultViewModelForArtboard(view.controller.activeArtboard!!)
        ```
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="Flutter">
    <Info>
      If you're using a `RiveWidgetController`, you can skip the step of creating a `ViewModel`. Go to [View Model Instances](#view-model-instances).
    </Info>
    ```dart
    // Get reference to the File and Artboard
    final file = await File.asset(
        'assets/my_file.riv',
        riveFactory: Factory.rive,
    );
    final artboard = file!.defaultArtboard()!;

    // Get reference by name
    file.viewModelByName("My View Model");

    // Get reference by index
    for (var i = 0; i < file.viewModelCount; i++) {
        final indexedVM = file.viewModelByIndex(i);
    }

    // Get reference to the default view model for an artboard
    final defaultVM = file.defaultArtboardViewModel(artboard);

    // Dispose the view model when you're no longer using it
    viewModel.dispose();
    ```
  </Tab>

  <Tab title="Unity">
    <Note>
      These APIs are only needed when the `Data Binding Mode` on the RiveWidget is set to `Manual`.

      Otherwise, you can configure view model binding directly in the Unity Inspector under the Data section.
    </Note>
    ```csharp
    private void OnEnable()
    {
        riveWidget.OnWidgetStatusChanged += HandleWidgetStatusChanged;
    }

    private void OnDisable()
    {
        riveWidget.OnWidgetStatusChanged -= HandleWidgetStatusChanged;
    }

    private void HandleWidgetStatusChanged()
    {
        if (riveWidget.Status == WidgetStatus.Loaded)
        {
            File file = riveWidget.File;

            // Get reference by name
            ViewModel viewModel = file.GetViewModelByName("My View Model");

            // Get reference by index
            for (int i = 0; i < file.ViewModelCount; i++)
            {
                ViewModel indexedVM = file.GetViewModelAtIndex(i);
            }

            // Get reference to the default view model for an artboard
            ViewModel defaultVM = riveWidget.Artboard.DefaultViewModel;
        }
    }
    ```
  </Tab>

  <Tab title="React Native">
    <Tabs>
      <Tab title="New Runtime (Recommended)">
        ```tsx
        import { useRiveFile } from '@rive-app/react-native';

        const { riveFile } = useRiveFile(require('./my_file.riv'));

        // Get reference by name
        const namedVM = riveFile?.viewModelByName('My View Model');

        // Get reference by index
        const indexVM = riveFile?.viewModelByIndex(0);

        // Get reference to the default artboard view model
        const defaultVM = riveFile?.defaultArtboardViewModel();
        ```
      </Tab>
      <Tab title="Legacy Runtime">
        <Info>
          Creating a view model object is only supported in the new React Native runtime.
        </Info>
      </Tab>
    </Tabs>
  </Tab>

</Tabs>

# View Model Instances

Once we have a reference to a view model, it can be used to create an instance. When creating an instance, you have four options:

1. Create a blank instance - Fill the properties of the created instance with default values as follows:

   | Type              | Value           |
   | ----------------- | --------------- |
   | Number            | 0               |
   | String            | Empty string    |
   | Boolean           | False           |
   | Color             | 0xFF000000      |
   | Trigger           | Untriggered     |
   | Enum              | The first value |
   | Image             | No image        |
   | Artboard          | No artboard     |
   | List              | Empty list      |
   | Nested view model | Null            |

2. Create the default instance - Use the instance labelled "Default" in the editor. Usually this is the one a designer intends as the primary one to be used at runtime.
3. Create by index - Using the order returned when iterating over all available instances. Useful when creating multiple instances by iteration.
4. Create by name - Use the editor's instance name. Useful when creating a specific instance.

<Note>
  In some samples, due to the wordiness of "view model instance", we use the abbreviation "VMI", as well as "VM" for "view model".
</Note>

<Tabs>
  <Tab title="Web">
    ```typescript
    // Create a blank instance from a view model (ViewModel)
    const vmiBlank = viewModel.instance();

    // Create a default instance from a view model (ViewModel)
    const vmiDefault = viewModel.defaultInstance();

    // Create an instance by index from a view model (ViewModel)
    for (let i = 0; i < viewModel.instanceCount; i++) {
        const vmiIndexed = viewModel.instanceByIndex(i);
    }

    // Create an instace by name from a view model (ViewModel)
    const vmiNamed = viewModel.instanceByName("My Instance");
    ```
  </Tab>

  <Tab title="React">
    Use the `useViewModelInstance` hook to create a view model instance from a view model returned by the `useViewModel` hook.

    ```typescript
    import { useRive, useViewModel, useViewModelInstance } from '@rive-app/react-webgl2';

    const { rive, RiveComponent } = useRive({
        src: 'your_file.riv',
        artboard: 'MyArtboard',
        stateMachine: 'MyStateMachine',
        // ... other options
    });

    const viewModel = useViewModel(rive, { name: 'MyViewModelName' });
    // Or: const viewModel = useViewModel(rive); // Default VM

    // Get default instance without binding
    const defaultUnbound = useViewModelInstance(viewModel, { useDefault: true });

    // Get named instance without binding
    const namedUnbound = useViewModelInstance(viewModel, { name: 'MyInstanceName' });

    // Create new blank instance without binding
    const newUnbound = useViewModelInstance(viewModel, { useNew: true });
    ```

    You can also bind the view model instance directly to the Rive instance by passing the `rive` object to the `useViewModelInstance` hook.

    ```typescript
    import { useRive, useViewModel, useViewModelInstance } from '@rive-app/react-webgl2';

    const { rive, RiveComponent } = useRive({
        src: 'your_file.riv',
        artboard: 'MyArtboard',
        stateMachine: 'MyStateMachine',
        autoBind: false, // Disable auto binding so we can manually bind later
        // ... other options
    });

    const viewModel = useViewModel(rive, { name: 'MyViewModelName' });

    // Get default instance (implicit) and bind it
    const defaultBound = useViewModelInstance(viewModel, { rive });

    // Get named instance and bind it
    const namedBound = useViewModelInstance(viewModel, { name: 'MyInstanceName', rive });

    // Create a new blank instance and bind it
    const newBound = useViewModelInstance(viewModel, { useNew: true, rive });
    ```

    If you set `autoBind: true` in `useRive`, you can access the automatically bound default instance directly via `rive.viewModelInstance` once Rive is loaded, without needing `useViewModel` or `useViewModelInstance`.

    ```typescript
    const { rive, RiveComponent } = useRive({
        src: 'your_file.riv',
        artboard: 'MyArtboard',
        stateMachine: 'MyStateMachine',
        autoBind: true,
    });

    // Once loaded, the instance is available:
    const boundInstance = rive?.viewModelInstance;
    ```
  </Tab>

  <Tab title="Apple">
    <Tabs>
        <Tab title={Apple.currentRuntimeName}>
            The following section assumes that you have read through the [Apple](/runtimes/apple/apple) overview.

            ```swift
            // From a file
            let file: File = ...

            // When using a view model by name:
            // A blank view model instance
            var blankInstance = try await file.createViewModelInstance(from: .blank(from: .name("ViewModel")))
            // The default instance for the view model
            var defaultInstance = try await file.createViewModelInstance(from: .name("ViewModel"))
            // An instance by name from the view model
            var namedInstance = try await file.createViewModelInstance(from: .name("Instance", from: .name("ViewModel")))

            // Alternatively, using the default view model for an artboard
            let artboard: Artboard = ...
            // A blank view model instance
            blankInstance = try await file.createViewModelInstance(from: .blank(from: .artboardDefault(Artboard)))
            // The default instance for the view model
            defaultInstance = try await file.createViewModelInstance(from: .viewModelDefault(from: .artboardDefault(Artboard)))
            // An instance by name from the view model
            namedInstance = try await file.createViewModelInstance(from: .name("Instance", from: .artboardDefault(Artboard)))
            ```
        </Tab>
            <Tab title={Apple.legacyRuntimeName}>
            ```swift
            let riveViewModel = RiveViewModel(...)
            let viewModel = riveViewModel.riveModel!.riveFile.viewModelNamed("...")!

            // Create blank
            let blankInstance = viewModel.createInstance()

            // Create default
            let defaultInstance = viewModel.createDefaultInstance()

            // Create by index
            for index in 0..<viewModel.instanceCount {
                let instanceByIndex = viewModel.createInstance(fromIndex: index)
            }

            // Create by name
            for name in viewModel.instanceNames {
                let instanceByName = viewModel.createInstance(fromName: name)
            }
            ```
        </Tab>
    </Tabs>
  </Tab>

  <Tab title="Android">
    <Tabs>
      <Tab title="Compose">
        See [View Models](#view-models) for how to get a `ViewModelSource` to use below. With that, you can use the builder pattern to create a `ViewModelInstanceSource`, the second half. That source can then be passed to `rememberViewModelInstance` to create and remember the instance for the lifetime of the composition.

        ```kotlin
        // From previous section
        val vmSource = ViewModelSource.Named("My View Model")

        // Blank instance source
        val vmiSourceBlank = ViewModelInstanceSource.Blank(vmSource)
        // or
        val vmiSourceBlank = vmSource.blankInstance()

        // Default instance source
        val vmiSourceDefault = ViewModelInstanceSource.Default(vmSource)
        // or
        val vmiSourceDefault = vmSource.defaultInstance()

        // Named instance source
        val vmiSourceNamed = ViewModelInstanceSource.Named(vmSource, "My Instance")
        // or
        val vmiSourceNamed = vmSource.namedInstance("My Instance")

        // The completed source can now be used along with the Rive file to create and remember the instance
        val viewModelInstance = rememberViewModelInstance(riveFile, vmiSourceNamed)
        ```

        Additionally, you can reference a nested view model instance from within a parent instance using the `Reference` variant.

        ```kotlin
        val myVMI = rememberViewModelInstance(riveFile, mySource)
        val referenceSource = ViewModelInstanceSource.Reference(myVMI, "Path/To/Nested VMI")
        val nestedVMI = rememberViewModelInstance(riveFile, referenceSource)
        ```
      </Tab>
      <Tab title="Legacy">
        ```kotlin
        val vm = view.controller.file?.getViewModelByName("My View Model")!!

        // Create blank
        val vmiBlank = vm.createBlankInstance()

        // Create default
        val vmiDefault = vm.createDefaultInstance()

        // Create by index
        for (i in 0 until vm.instanceCount) {
            val vmiIndexed = vm.createInstanceFromIndex(i)
        }

        // Create by name
        val vmiNamed = vm.createInstanceFromName("My Instance")
        ```
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="Flutter">
    If you're using  `RiveWidgetController`:

    ```dart
    // Get reference to the File
    file = await File.asset(
        'assets/rewards.riv',
        riveFactory: Factory.rive,
    );

    // Create a controller
    controller = RiveWidgetController(file!);

    // Data bind by name
    viewModelInstance = controller.dataBind(DataBind.byName('My View Model'));

    // Data bind by index
    viewModelInstance = controller.dataBind(DataBind.byIndex(0));

    // Auto data bind
    viewModelInstance = controller.dataBind(DataBind.auto());

    // Bind some existing view model instance to the controller:
    viewModelInstance = controller.dataBind(DataBind.byInstance(someViewModelInstance));

    // Dispose of objects you created when no longer needed
    viewModelInstance.dispose();
    controller.dispose();
    file.dispose();
    ```

    If you want to manage the creation of view model instances yourself:

    ```dart
    final vm = file.viewModelByName("My View Model")!;

    // Create blank
    final vmiBlank = vm.createInstance();

    // Create default
    final vmiDefault = vm.createDefaultInstance();

    // Create by index
    for (int i = 0; i < vm.instanceCount; i++) {
    final vmiIndexed = vm.createInstanceByIndex(i);
    }

    // Create by name
    final vmiNamed = vm.createInstanceByName("My Instance");

    // Dispose the view model instance
    viewModelInstance.dispose();
    ```
  </Tab>

  <Tab title="Unity">
    <Note>
      These APIs are only needed when the `Data Binding Mode` on the RiveWidget is set to `Manual`.

      Otherwise, you can configure view model binding directly in the Unity Inspector under the Data section.
    </Note>
    ```csharp
    private void OnEnable()
    {
        riveWidget.OnWidgetStatusChanged += HandleWidgetStatusChanged;
    }

    private void OnDisable()
    {
        riveWidget.OnWidgetStatusChanged -= HandleWidgetStatusChanged;
    }

    private void HandleWidgetStatusChanged()
    {
        if (riveWidget.Status == WidgetStatus.Loaded)
        {
            // From a ViewModel reference
            ViewModel vm = riveWidget.File.GetViewModelByName("My View Model");

            // Create blank
            ViewModelInstance vmiBlank = vm.CreateInstance();

            // Create default
            ViewModelInstance vmiDefault = vm.CreateDefaultInstance();

            // Create by index
            for (int i = 0; i < vm.InstanceCount; i++)
            {
                ViewModelInstance vmiIndexed = vm.CreateInstanceAt(i);
            }

            // Create by name
            ViewModelInstance vmiNamed = vm.CreateInstanceByName("My Instance");
        }
    }
    ```
  </Tab>

  <Tab title="React Native">
    <Tabs>
      <Tab title="New Runtime (Recommended)">
        Use the `useViewModelInstance` hook to create a view model instance. You can pass a `RiveFile`, `ViewModel`, or `RiveViewRef` as the source.

        ```tsx
        import { useRiveFile, useViewModelInstance, RiveView } from '@rive-app/react-native';

        const { riveFile } = useRiveFile(require('./my_file.riv'));

        // Get default instance from RiveFile (recommended)
        const instance = useViewModelInstance(riveFile);

        // Get instance by name from a ViewModel
        const viewModel = riveFile?.viewModelByName('My View Model');
        const namedInstance = useViewModelInstance(viewModel, { name: 'My Instance' });

        // Create a new blank instance
        const newInstance = useViewModelInstance(viewModel, { useNew: true });

        // With required: true (throws if null, use with Error Boundary)
        const instance = useViewModelInstance(riveFile, { required: true });

        // With onInit to set initial values synchronously
        const instance = useViewModelInstance(riveFile, {
            onInit: (vmi) => {
                vmi.numberProperty('count')?.set(10);
                vmi.stringProperty('name')?.set('Initial Name');
            }
        });

        return (
            <RiveView
                file={riveFile}
                dataBind={instance}
                autoPlay={true}
            />
        );
        ```

        You can also get the auto-bound instance from a `RiveViewRef`:

        ```tsx
        import { useRive, useViewModelInstance } from '@rive-app/react-native';

        const { riveViewRef, setHybridRef } = useRive();
        const instance = useViewModelInstance(riveViewRef);
        ```

      </Tab>
      <Tab title="Legacy Runtime">
        You can bind a view model instance to a Rive component by passing in a `dataBinding` prop to the Rive component.

        The `dataBinding` prop accepts a `DataBindBy` type, which can be one of the following:

        ```typescript
        export type DataBindBy =
            | { type: 'autobind'; value: boolean }
            | { type: 'index'; value: number }
            | { type: 'name'; value: string }
            | { type: 'empty' };

        export const AutoBind = (value: boolean): DataBindBy => ({
            type: 'autobind',
            value,
        });
        export const BindByIndex = (value: number): DataBindBy => ({
            type: 'index',
            value,
        });
        export const BindByName = (value: string): DataBindBy => ({
            type: 'name',
            value,
        });
        export const BindEmpty = (): DataBindBy => ({ type: 'empty' });
        ```

        Example usage:

        ```typescript {7,8,9,10}
        const [setRiveRef, riveRef] = useRive();

        return (
            <Rive
                ref={setRiveRef}
                autoplay={true}
                dataBinding={AutoBind(true)} // default: `AutoBind(false)`
                // dataBinding={BindByIndex(0)}
                // dataBinding={BindByName('SomeName')}
                // dataBinding={BindEmpty()}
                stateMachineName={'State Machine 1'}
                resourceName={'rewards'}
            />
        );
        ```

        You can listen to errors by passing in the `onError={(riveError: RNRiveError)` prop to the Rive component.
        The `riveError` object contains the error type and message, and you can filter out for `RNRiveErrorType.DataBindingError`:

        ```typescript
        onError={(riveError: RNRiveError) => {
            switch (riveError.type) {
                case RNRiveErrorType.DataBindingError: {
                console.error(`${riveError.message}`);
                return;
                }
                default:
                console.error('Unhandled error');
                return;
            }
        }}
        ```
      </Tab>
    </Tabs>
  </Tab>

</Tabs>

### Binding

The created instance can then be assigned to a state machine or artboard. This establishes the bindings set up at edit time.

It is preferred to assign to a state machine, as this will automatically apply the instance to the artboard as well. Only assign to an artboard if you are not using a state machine, i.e. your file is static or uses linear animations.

<Note>
  The initial values of the instance are not applied to their bound elements until the state machine or artboard advances.
</Note>

<Tabs>
  <Tab title="Web">
    ```typescript
    const rive = new rive.Rive({
        autoBind: false, // This should be set to false (default)
        onLoad: () => {
            const vm = rive.viewModelByName("My View Model");
            const vmi = vm.instanceByName("My Instance");

            // Manually bind by applying the instance to the state machine and artboard
            rive.bindViewModelInstance(vmi);
        }
    });
    ```
  </Tab>

  <Tab title="React">
    For React, no additional steps are needed to bind the view model instance to the Rive component. Passing the `rive` object to `useViewModelInstance` handles this automatically.
  </Tab>

  <Tab title="Apple">
    <Tabs>
        <Tab title={Apple.currentRuntimeName}>
            Given the following example code:
            ```swift
            let file: File = ...
            let artboard: Artboard = try await file.createArtboard()
            let stateMachine: StateMachine = try await artboard.createStateMachine()
            let viewModelInstance = try await file.createViewModelInstance(...)
            ```

            You can manually bind the view model instance to the state machine:
            ```swift
            stateMachine.bindViewModelInstance(viewModelInstance)
            ```

            Alternatively, you can utilize the `Rive` type to (automatically) data bind a view model instance:
            ```swift
            // Automatically find a default view model instance to bind. This is the default value, if you do not pass in a dataBind argument.
            var rive = try await Rive(file: file, artboard: artboard, stateMachine: stateMachine, dataBind: .auto)
            // Bind a view model instance
            var rive = try await Rive(file: file, artboard: artboard, stateMachine: stateMachine, dataBind: .viewModelInstance(viewModelInstance))
            // Do not bind. This assumes you have manually bound a view model instance earlier
            var rive = try await Rive(file: file, artboard: artboard, stateMachine: stateMachine, dataBind: .none)
            ```
        </Tab>
        <Tab title={Apple.legacyRuntimeName}>
            ```swift
            let riveViewModel = RiveViewModel(...)
            let artboard = riveViewModel.riveModel!.artboard,
            let instance = riveViewModel.riveModel!.riveFile.defaultViewModel(for: artboard).createDefaultInstance()!

            // Apply the instance to the state machine (preferred)
            // Applying to a state machine will automatically bind to its artboard
            riveViewModel.riveModel!.stateMachine.bind(instance)

            // Alternatively, apply the instance to the artboard
            artboard.bind(viewModelInstance: instance)
            ```
        </Tab>
    </Tabs>
  </Tab>

  <Tab title="Android">
    <Tabs>
      <Tab title="Compose">
        See the [Compose data binding example](https://github.com/rive-app/rive-android/blob/master/app/src/main/java/app/rive/runtime/example/ComposeDataBindingActivity.kt).

        Binding to the state machine happens automatically when the `ViewModelInstance` is passed to the `Rive` composable.

        ```kotlin {6}
        val vmiSource = ViewModelSource.Named("My View Model").namedInstance("My Instance")
        val vmi = rememberViewModelInstance(riveFile, vmiSource)

        Rive(
            riveFile,
            viewModelInstance = vmi
        )
        ```
      </Tab>
      <Tab title="Legacy">
        See the [Legacy data binding example](https://github.com/rive-app/rive-android/blob/master/app/src/main/java/app/rive/runtime/example/LegacyDataBindingActivity.kt).

        ```kotlin
        view.setRiveResource(
            R.raw.my_rive_file,
            artboardName = "My Artboard",
        )

        val vm = view.controller.file?.getViewModelByName("My View Model")!!
        val vmi = vm.createInstanceFromName("My Instance")

        // Apply the instance to the state machine (preferred)
        view.controller.stateMachines.first().viewModelInstance = vmi

        // Alternatively, apply the instance to the artboard
        view.controller.activeArtboard?.viewModelInstance = vmi
        ```
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="Flutter">
    If you're using `RiveWidgetController` the binding happens automatically when you call any of the following:

    ```dart
    viewModelInstance = controller.dataBind(DataBind.auto());
    viewModelInstance = controller.dataBind(DataBind.byName('My View Model'));
    viewModelInstance = controller.dataBind(DataBind.byIndex(0));
    viewModelInstnace = controller.dataBind(someViewModelInstance);
    ```

    Else, you need to make sure to bind the view model instance to the state machine, or artboard.

    ```dart
    final file = await File.asset(
    'assets/my_file.riv',
    riveFactory: Factory.rive,
    );

    final artboard = file!.defaultArtboard();
    final stateMachine = artboard!.defaultStateMachine()!;

    final vm = file.defaultArtboardViewModel(artboard)!;
    final vmi = vm.createDefaultInstance()!;

    // Bind to the state machine. This automatically binds to the artboard as well.
    stateMachine.bindViewModelInstance(vmi);

    // If you're not using a state machine, bind to the artboard
    artboard.bindViewModelInstance(vmi);
    ```
  </Tab>

  <Tab title="Unity">
    ```csharp
    // Access the RiveWidget component

    // Using the Unity Inspector
    // 1. Select your RiveWidget in the Inspector
    // 2. In the "Data" section, set the Data Binding Mode:
    //    - Auto Bind Default: Automatically binds the default view model instance
    //    - Auto Bind Selected: Uses a specific instance you select in the dropdown
    //    - Manual: Requires you to manually set up binding in code

    // Or programmatically if set to Manual or if using the low-level API
    private void OnEnable()
    {
        riveWidget.OnWidgetStatusChanged += HandleWidgetStatusChanged;
    }

    private void OnDisable()
    {
        riveWidget.OnWidgetStatusChanged -= HandleWidgetStatusChanged;
    }

    private void HandleWidgetStatusChanged()
    {
        if (riveWidget.Status == WidgetStatus.Loaded)
        {
            ViewModel vm = riveWidget.Artboard.DefaultViewModel;
            ViewModelInstance vmi = vm.CreateDefaultInstance();

            // Applying to a state machine will automatically bind to its artboard
            riveWidget.StateMachine.BindViewModelInstance(vmi);
        }
    }

    ```
  </Tab>

  <Tab title="React Native">
    <Tabs>
      <Tab title="New Runtime (Recommended)">
        For React Native, no additional steps are needed to bind the view model instance to the Rive component. Pass the instance to the `dataBind` prop on `RiveView`:

        ```tsx
        import { RiveView, useRiveFile, useViewModelInstance } from '@rive-app/react-native';

        const { riveFile } = useRiveFile(require('./my_file.riv'));
        const instance = useViewModelInstance(riveFile);

        return (
            <RiveView
                file={riveFile}
                dataBind={instance}
            />
        );
        ```
      </Tab>
      <Tab title="Legacy Runtime">
        For React Native, no additional steps are needed to bind the view model instance to the Rive component. The `dataBinding` prop handles this automatically.
      </Tab>
    </Tabs>
  </Tab>

</Tabs>

### Auto-Binding

Alternatively, you may prefer to use auto-binding. This will automatically bind the default view model of the artboard using the default instance to both the state machine and the artboard. The default view model is the one selected on the artboard in the editor dropdown. The default instance is the one marked "Default" in the editor.

<Tabs>
  <Tab title="Web">
    ```typescript {4}
    const rive = new rive.Rive({
        src: "my_rive_file.riv",
        canvas: document.getElementById("canvas"),
        autoBind: true,
        onLoad: () => {
            // Access the current instance that was auto-bound
            let boundInstance = rive.viewModelInstance;
        }
    });
    ```
  </Tab>

  <Tab title="React">
    ```typescript
    const { rive, RiveComponent } = useRive({
        src: 'your_file.riv',
        artboard: 'MyArtboard',
        stateMachine: 'MyStateMachine',
        autoBind: true, // Enable auto-binding
        // ... other options
    });

    // Once loaded, the instance is available:
    const boundInstance = rive?.viewModelInstance;
    ```
  </Tab>
  <Tab title="Apple">
    <Tabs>
        <Tab title={Apple.currentRuntimeName}>
            Given the following example code:
            ```swift
            let file: File = ...
            let artboard: Artboard = try await file.createArtboard()
            let stateMachine: StateMachine = try await artboard.createStateMachine()
            let viewModelInstance = try await file.createViewModelInstance(...)
            ```

            When creating a `Rive` object, you can elect to auto bind:
            ```swift
            // Automatically find a default view model instance to bind. This is the default value, if you do not pass in a dataBind argument.
            var rive = try await Rive(file: file, artboard: artboard, stateMachine: stateMachine, dataBind: .auto)
            // or
            var rive = try await Rive(file: file, artboard: artboard, stateMachine: stateMachine)
            ```
        </Tab>
        <Tab title={Apple.legacyRuntimeName}>
            ```swift
            let riveViewModel = RiveViewModel(...)
            riveViewModel.riveModel?.enableAutoBind { instance in
                // Store a reference to `instance` to later access properties
                // The instance may change as state machines and artboards change
            }

            // If you'd like to disable autoBind after enabling…
            riveViewModel.riveModel!.disableAutoBind()
            ```
        </Tab>
    </Tabs>
  </Tab>

  <Tab title="Android">
    <Tabs>
      <Tab title="Compose">
        Auto-binding does not exist in the Compose API due to the nature of composables. Since they are functions, it is difficult to get values out of them as compared to classes. Callbacks would require a null placeholder to remember the value before it has fired which creates more overhead than supplying the instance directly.

        The equivalent is to create a view model instance with no source. This will internally create the default artboard, the default view model for that artboard, and the default instance for that view model. You can then pass that into the `Rive` composable.

        ```kotlin
        val vmi = rememberViewModelInstance(riveFile)
        Rive(
            riveFile,
            viewModelInstance = vmi,
        )
        ```
      </Tab>
      <Tab title="Legacy">
        ```kotlin {3}
        view.setRiveResource(
            R.raw.my_rive_file,
            autoBind = true,
        )
        ```
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="Flutter">
    ```dart
    // Get reference to the File
    file = await File.asset(
        'assets/rewards.riv',
        riveFactory: Factory.rive,
    );

    // Create a controller
    controller = RiveWidgetController(file!);

    // Auto data bind
    viewModelInstance = controller.dataBind(DataBind.auto());

    // Dispose of objects you created when no longer needed
    viewModelInstance.dispose();
    controller.dispose();
    file.dispose();
    ```
  </Tab>

  <Tab title="Unity">
    **Rive Widget** provides both visual and programmatic ways to configure auto-binding. In the Inspector, you can easily set up binding through the Data Binding Mode dropdown:

    ![Data Binding Mode dropdown in Unity Inspector showing Auto Bind options](/images/unity/widget-db-binding-mode-dropdown.jpg)

    To enable auto-binding programmatically, use the following APIs:

    ```csharp

    // Before the widget is loaded:

    // Option 1: Auto bind the default instance
    riveWidget.BindingMode = DataBindingMode.AutoBindDefault;

    // Option 2: Auto bind a specific instance by name
    riveWidget.BindingMode = DataBindingMode.AutoBindSelected;
    riveWidget.ViewModelInstanceName = "My Instance";

    // Load the Rive file after setting the binding mode
    riveWidget.Load(riveFile, artboardName, stateMachineName);

    ...
    // Access the current instance that was auto-bound
    ViewModelInstance boundInstance = riveWidget.StateMachine.ViewModelInstance;
    ```
  </Tab>

  <Tab title="React Native">
    <Tabs>
      <Tab title="New Runtime (Recommended)">
        Auto-binding is available through the `DataBindMode` enum. You can pass `DataBindMode.Auto` to the `dataBind` prop:

        ```tsx
        import { RiveView, useRiveFile, DataBindMode } from '@rive-app/react-native';

        const { riveFile } = useRiveFile(require('./my_file.riv'));

        return (
            <RiveView
                file={riveFile}
                dataBind={DataBindMode.Auto}
                autoPlay={true}
            />
        );
        ```

        You can also bind by name:

        ```tsx
        <RiveView
            file={riveFile}
            dataBind={{ byName: 'My Instance' }}
            autoPlay={true}
        />
        ```

        Or bind a specific instance:

        ```tsx
        const instance = useViewModelInstance(riveFile);
        <RiveView
            file={riveFile}
            dataBind={instance}
            autoPlay={true}
        />
        ```
      </Tab>
      <Tab title="Legacy Runtime">
        The default value for the `dataBinding` prop is `AutoBind(false)`, which means auto-binding is disabled by default.

        To enable auto-binding, set the `dataBinding` prop to `AutoBind(true)`.

        ```typescript {7}
        const [setRiveRef, riveRef] = useRive();

        return (
            <Rive
                ref={setRiveRef}
                autoplay={true}
                dataBinding={AutoBind(true)} // default: `AutoBind(false)`
                stateMachineName={'State Machine 1'}
                resourceName={'rewards'}
            />
        );
        ```
      </Tab>
    </Tabs>
  </Tab>

</Tabs>

# Properties

A property is a value that can be read, set, or observed on a view model instance. Properties can be of the following types:

| Type                   | Supported |
| ---------------------- | --------- |
| Floating point numbers | ✅        |
| Booleans               | ✅        |
| Triggers               | ✅        |
| Strings                | ✅        |
| Enumerations           | ✅        |
| Colors                 | ✅        |
| Nested View Models     | ✅        |
| Lists                  | ✅        |
| Images                 | ✅        |
| Artboards              | ✅        |

For more information on version compatibility, see the [Feature Support](/feature-support) page.

### Listing Properties

Property descriptors can be inspected on a view model to discover at runtime which are available. These are not the mutable properties themselves though - once again those are on instances. These descriptors have a type and name.

<Tabs>
  <Tab title="Web">
    ```typescript
    // A list of properties on a view model (ViewModel)
    const properties = viewModel.properties;
    console.log(properties);
    ```
  </Tab>

  <Tab title="React">
    ```typescript
    // Access properties from the view model returned by useViewModel
    const viewModel = useViewModel(rive);
    console.log(viewModel?.properties);
    ```
  </Tab>

  <Tab title="Apple">
    <Tabs>
        <Tab title={Apple.currentRuntimeName}>
            ```swift
            let file: File = ...
            let properties = try await file.getProperties(of: "ViewModel")
            for property in properties {
                print(property.type) // enum of string, number, boolean, etc
                print(property.name) // The name of the property within the view model
                print(property.metaData) // Additional metadata for the property, if available
            }
            ```
        </Tab>
        <Tab title={Apple.legacyRuntimeName}>
            ```swift
            let riveViewModel = RiveViewModel(...)
            let viewModel = riveViewModel.riveModel!.file.viewModelNamed(...)!
            for property in viewModel.properties {
                print(property.type) // String, number, boolean, etc
                print(property.name) // The name of the property within the view model
            }
            ```
        </Tab>
    </Tabs>
  </Tab>

  <Tab title="Android">
    <Tabs>
      <Tab title="Compose">
        Getting view model properties is a suspend operation, so it needs to be called from a coroutine scope such as `LaunchedEffect`.

        ```kotlin
        LaunchedEffect(riveFile) {
            riveFile.getViewModelProperties("My View Model").forEach { property ->
                Log.d("My Tag", "Property Name: ${property.name}, Type: ${property.type}")
            }
        }
        ```
      </Tab>
      <Tab title="Legacy">
        ```kotlin
        val vm = view.controller.file?.getViewModelByName("My View Model")!!

        // A list of properties
        val properties = vm.properties
        assertContains(
            properties,
            ViewModel.Property(ViewModel.PropertyDataType.NUMBER, "My Number Property")
        )
        ```
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="Flutter">
    ```dart
    // Accesss on a ViewModel object
    print("Properties: ${viewModel.properties}");

    // Access on a ViewModelInstance object
    print("Properties: ${viewModelInstance.properties}");
    ```
  </Tab>

  <Tab title="Unity">
    ```csharp
    var vm = riveWidget.File.GetViewModelByName("My View Model");

    // A list of properties
    var properties = vm.Properties;
    foreach (var prop in properties)
    {
        Debug.Log($"Property: {prop.Name}, Type: {prop.Type}");
    }
    ```
  </Tab>

  <Tab title="React Native">
    <Tabs>
      <Tab title="New Runtime (Recommended)">
        <Note>Coming soon</Note>
      </Tab>
      <Tab title="Legacy Runtime">
        <Warning>
          The properties API is not supported on the legacy runtime.
        </Warning>
      </Tab>
    </Tabs>
  </Tab>

</Tabs>

### Reading and Writing Properties

References to these properties can be retrieved by name or path.

Some properties are mutable and have getters, setters, and observer operations for their values. Getting or observing the value will retrieve the latest value set on that property's binding, as of the last state machine or artboard advance. Setting the value will update the value and all of its bound elements.

<Note>
  After setting a property's value, the changes will not apply to their bound elements until the state machine or artboard advances.
</Note>

<Tabs>
  <Tab title="Web">
    ```typescript
    const rive = new rive.Rive({
        autoBind: true,
        onLoad: () => {
            // Access the current instance that was auto-bound
            let vmi = rive.viewModelInstance;

            // Booleans
            const booleanProperty = vmi.boolean("My Boolean Property");
            const booleanValue = booleanProperty.value;
            booleanProperty.value = true;

            // Strings
            const stringProperty = vmi.string("My String Property");
            const stringValue = stringProperty.value;
            stringProperty.value = "Hello, Rive!";

            // Numbers
            const numberProperty = vmi.number("My Number Property");
            const numberValue = numberProperty.value;
            numberProperty.value = 10;

            // Colors
            const colorProperty = vmi.color("My Color Property");
            const colorValue = colorProperty.value;
            colorProperty.value = 0xFF000000; // Set color to black with 100% opacity

            // Other ways to set color
            colorProperty.rgb(255, 0, 0); // Set RGB to red
            colorProperty.rbga(255, 0, 0, 128); // Set RGBA to red with 50% opacity
            colorProperty.argba(128, 255, 0, 0); // Set RGBA to red with 50% opacity
            colorProperty.opacity(0.5); // Set opacity to 50%

            // Triggers
            const triggerProperty = vmi.trigger("My Trigger Property");
            triggerProperty.trigger();

            // Enumerations
            const enumProperty = vmi.enum("My Enum Property");
            const enumValue = enumProperty.value;
            enumProperty.value = "Option1";
        }
    });
    ```
  </Tab>

  <Tab title="React">
    Use the specific hook for a given property type to get and set property values.

    - `useViewModelInstanceBoolean`: Read/write boolean properties
    - `useViewModelInstanceString`: Read/write string properties
    - `useViewModelInstanceNumber`: Read/write number properties
    - `useViewModelInstanceColor`: Read/write color properties with additional RGB/alpha methods
    - `useViewModelInstanceEnum`: Read/write enum properties with available values
    - `useViewModelInstanceTrigger`: Fire trigger events with optional callbacks

    These hooks return the current `value` and a function to update it (`setValue`, `setRgb`, `trigger`). The `value` will be null if the property is not found or if the hook is provided with an invalid viewModelInstance.

    ```typescript
    import {
        useViewModelInstanceBoolean,
        useViewModelInstanceString,
        useViewModelInstanceNumber,
        useViewModelInstanceEnum,
        useViewModelInstanceColor,
        useViewModelInstanceTrigger
    } from '@rive-app/react-webgl2';

    // Assuming viewModelInstance is obtained via useViewModelInstance or rive.viewModelInstance

    // Boolean
    const { value: isActive, setValue: setIsActive } = useViewModelInstanceBoolean(
        'isToggleOn', // Property path
        viewModelInstance
    );
    // Set: setIsActive(true);

    // String
    const { value: userName, setValue: setUserName } = useViewModelInstanceString(
        'user/name', // Property path
        viewModelInstance
    );
    // Set: setUserName('Rive');

    // Number
    const { value: score, setValue: setScore } = useViewModelInstanceNumber(
        'levelScore', // Property path
        viewModelInstance
    );
    // Set: setScore(100);

    // Enum
    const { value: status, setValue: setStatus, values: statusOptions } = useViewModelInstanceEnum(
        'appStatus', // Property path
        viewModelInstance
    );
    // Set: setStatus('loading');
    // Get available options: statusOptions is an array like ['idle', 'loading', 'error']

    // Color
    const {
        value: themeColor, // Raw number value like -3267805
        setRgb: setThemeColorRgb, // Set RGB components (0-255 values)
        setAlpha: setThemeColorAlpha, // Set alpha component (0-255)
        setOpacity: setThemeColorOpacity, // Set opacity (0.0-1.0)
        setRgba: setThemeColorRgba, // Set all components at once
        setValue: setThemeColorValue // Set raw color value
    } = useViewModelInstanceColor(
        'ui/themeColor', // Property path
        viewModelInstance
    );
    // Set RGB: setThemeColorRgb(0, 128, 255); // Set to a blue color
    // Set Alpha: setThemeColorAlpha(128); // Set to 50% opacity
    // Set Opacity: setThemeColorOpacity(0.5); // Set to 50% opacity
    // Set RGBA: setThemeColorRgba(0, 128, 255, 255); // Blue with full opacity
    // Set Value: setThemeColorValue(-3267805); // Set using raw color value

    // Trigger (No value, just a trigger function)
    const { trigger: playEffect } = useViewModelInstanceTrigger(
        'playButtonEffect', // Property path
        viewModelInstance,
        {
            // Optional callback to be called when the trigger is fired
            onTrigger: () => {
                console.log('Trigger Fired!');
            }
        }
    );
    // Trigger: playEffect();
    ```

    The `value` returned by each hook will update automatically when the property changes in the Rive graphic.
  </Tab>

  <Tab title="Apple">
    <Tabs>
        <Tab title={Apple.currentRuntimeName}>
            Property types are a very thin wrapper around the path and return type of a property.

            All property APIs (e.g setters, getters, and triggers) are available as part of a `ViewModelInstance` object.

            <CodeGroup>
              ```swift String
              let file: File = ...
              let viewModelInstance = try await file.createViweModelInstance(...)

              // String
              let stringProperty = StringProperty(path: "path/to/string")
              let stringValue = try await viewModelInstance.value(of: stringProperty)
              viewModelInstance.setValue(of: stringProperty, to: "value")
              ```

              ```swift Number
              let file: File = ...
              let viewModelInstance = try await file.createViweModelInstance(...)

              let numberProperty = NumberProperty(path: "path/to/number")
              let numberValue = try await viewModelInstance.value(of: numberProperty)
              viewModelInstance.setValue(of: numberValue, to: 9001)
              ```

              ```swift Bool
              let file: File = ...
              let viewModelInstance = try await file.createViweModelInstance(...)

              let boolProperty = BoolProperty(path: "path/to/bool")
              let boolValue = try await viewModelInstance.value(of: boolProperty)
              viewModelInstance.setValue(of: boolProperty, to: true)
              ```

              ```swift Color
              let file: File = ...
              let viewModelInstance = try await file.createViweModelInstance(...)

              let colorProperty = ColorProperty(path: "path/to/color")
              let colorValue = try await viewModelInstance.value(of: colorProperty)
              viewModelInstance.setValue(of: colorProperty, to: Color(red: 255, green: 255, blue: 255, alpha: 255))
              ```

              ```swift Enum
              let file: File = ...
              let viewModelInstance = try await file.createViweModelInstance(...)

              let enumProperty = EnumProperty(path: "path/to/enum")
              let enumValue = try await viewModelInstance.value(of: enumProperty)
              viewModelInstance.setValue(of: enumProperty, to: "value")
              ```

              ```swift Trigger
              let file: File = ...
              let viewModelInstance = try await file.createViweModelInstance(...)

              let triggerProperty = TriggerProperty(path: "path/to/trigger")
              viewModelInstance.fire(trigger: triggerProperty)
              ```
            </CodeGroup>
        </Tab>
        <Tab title={Apple.legacyRuntimeName}>
            ```swift
            let riveViewModel = RiveViewModel(...)

            var viewModelInstance: RiveDataBindingViewModel.Instance!

            // You can get the view model instance when enabling auto binding
            riveViewModel.riveModel?.enableAutoBind { instance in
                // Store a reference to instance
                viewModelInstance = instance
            }

            // Alternatively, you can create a view model instance manually
            viewModelInstance = riveViewModel.riveModel!.riveFile.viewModelNamed("...")!.createDefaultInstance()!

            // Strings
            let stringProperty = instance.stringProperty(fromPath: "...")!
            // Updating its value
            stringProperty.value = "Hello, Rive"
            // Get its value
            print(stringProperty.value)

            // You can also set and get values without storing a strong reference
            instance.stringProperty(fromPath: "...").value = "Hello again, Rive"

            // Numbers
            let numberProperty = instance.numberProperty(fromPath: "...")!
            // Updating its value
            numberProperty.value = 1337
            // Get its value
            print(numberProperty.value)

            // You can also set and get values without storing a strong reference
            instance.numberProperty(fromPath: "...").value = 1337

            // Booleans
            let booleanProperty = instance.booleanProperty(fromPath: "...")!
            // Updating its value
            booleanProperty.value = true
            // Get its value
            print(booleanProperty.value)

            // You can also set and get values without storing a strong reference
            instance.booleanProperty(fromPath: "...").value = true

            // Colors
            let colorProperty = instance.colorProperty(fromPath: "...")!
            // Updating its value, which is a UIColor/NSColor, so all static helpers apply.
            colorProperty.value = .red
            // Get its value
            print(colorProperty.value)

            // You can also set and get values without storing a strong reference
            instance.colorProperty(fromPath: "...").value = .red

            // Enums
            let enumProperty = instance.enumProperty(fromPath: "...")!
            // Updating its value
            enumProperty.value = "Foo"
            // Get its value
            print(enumProperty.value)
            // Print all possible values
            print(enumProperty.values)

            // You can also set and get values without storing a strong reference
            instance.enumProperty(fromPath: "...").value = "Foo"

            // Trigger
            let triggerProperty = instance.triggerProperty(fromPath: "...")!
            // Fire the trigger
            triggerProperty.trigger()
            ```
        </Tab>
    </Tabs>
  </Tab>

  <Tab title="Android">
    <Tabs>
      <Tab title="Compose">
        ### Writing Values
        The Compose API does not have explicit property objects. Instead, property values are set on the `ViewModelInstance` directly using methods which take their path.

        ```kotlin
        val vmi = rememberViewModelInstance(...)
        vmi.setNumberProperty("Path/To/Property", 10f)
        ```

        ### Reading  Values
        Values are read throw a Kotlin [`Flow`](https://kotlinlang.org/docs/flow.html) which emits the latest value whenever it changes. You can collect this flow in a `LaunchedEffect` or convert it to a `State` using `collectAsState()` (or use `collectAsStateWithLifecycle()` to only collect during certain lifecycle states).

        To get the latest value once without observing, you can use the terminal `first()` operator.

        ```kotlin
        val vmi = rememberViewModelInstance(...)
        // Collect as State
        val numberValue by vmi.numberPropertyFlow("Path/To/Property").collectAsState(initial = 0f)

        Text(text = "Number value: $numberValue")

        // Or collect
        LaunchedEffect(vmi) {
            vmi.numberPropertyFlow("Path/To/Property").collect { value ->
                Log.d("Rive", "Number value changed: $value")
            }

            // Or get once
            val numberValue = vmi.numberPropertyFlow("Path/To/Property").first()
            Log.d("Rive", "Current number value: $numberValue")
        }
        ```
      </Tab>
      <Tab title="Legacy">
        ```kotlin
        val vm = view.controller.file?.getViewModelByName("My View Model")!!
        val vmi = vm.createInstanceFromName("My Instance")

        val numberProperty = vmi.getNumberProperty("My Number Property")
        // Get
        val numberValue = numberProperty.value
        // Set
        numberProperty.value = 10f
        ```
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="Flutter">
    ```dart
    // Get reference to the ViewModel instance
    final vmi = someExistingViewModelInstance;

    final numberProperty = vmi.number("My Number Property")!;
    // Get
    final numberValue = numberProperty.value;

    // Set
    numberProperty.value = 10;

    // Observe
    void onNumberChange(double value) {
        print("Number changed to: $value");
    }
    numberProperty.addListener(onNumberChange);

    // Remove listener when done
    numberProperty.removeListener(onNumberChange);

    // Alternatively, clear all listeners
    numberProperty.clearListeners();

    // Dispose of the property to clear up resources when you're no longer using it
    // This will call `clearListeners()` internally.
    numberProperty.dispose();
    ```
  </Tab>

  <Tab title="Unity">
    ```csharp
    private void OnEnable()
    {
        riveWidget.OnWidgetStatusChanged += HandleWidgetStatusChanged;
    }

    private void OnDisable()
    {
        riveWidget.OnWidgetStatusChanged -= HandleWidgetStatusChanged;
    }

    private void HandleWidgetStatusChanged()
    {
        // Check if the widget is loaded before accessing the view model instance
        if (riveWidget.Status == WidgetStatus.Loaded)
        {
            ViewModelInstance viewModelInstance = riveWidget.StateMachine.ViewModelInstance;

         //==========================================================================
        // STRING PROPERTIES
        //==========================================================================
            ViewModelInstanceStringProperty stringProperty = viewModelInstance.GetStringProperty("title");
            Debug.Log($"String value: {stringProperty.Value}");
            stringProperty.Value = "New Text";

        //==========================================================================
        // NUMBER PROPERTIES
        //==========================================================================
            ViewModelInstanceNumberProperty numberProperty = viewModelInstance.GetNumberProperty("count");
            Debug.Log($"Number value: {numberProperty.Value}");
            numberProperty.Value = 42.5f;

        //==========================================================================
        // BOOLEAN PROPERTIES
        //==========================================================================
            ViewModelInstanceBooleanProperty boolProperty = viewModelInstance.GetBooleanProperty("isActive");
            Debug.Log($"Boolean value: {boolProperty.Value}");
            boolProperty.Value = true;

        //==========================================================================
        // COLOR PROPERTIES
        //==========================================================================
            ViewModelInstanceColorProperty colorProperty = viewModelInstance.GetColorProperty("backgroundColor");
            // Using Unity Color (float values 0-1)
            Color currentColor = colorProperty.Value;
            colorProperty.Value = new UnityEngine.Color(1, 0, 0, 1); // Red color
            // Or using Color32 (byte values 0-255)
            Color32 currentColor32 = colorProperty.Value32;
            colorProperty.Value32 = new Color32(0, 255, 0, 255); // Green color

        //==========================================================================
        // ENUM PROPERTIES
        //==========================================================================
            ViewModelInstanceEnumProperty enumProperty = viewModelInstance.GetEnumProperty("category");
            Debug.Log($"Enum current value: {enumProperty.Value}");
            Debug.Log($"Enum available values: {string.Join(", ", enumProperty.EnumValues)}");
            enumProperty.Value = "option_name";

        //==========================================================================
        // TRIGGER PROPERTIES
        //==========================================================================
            ViewModelInstanceTriggerProperty triggerProperty = viewModelInstance.GetTriggerProperty("onSubmit");
            triggerProperty.Trigger(); // Fire the trigger
        }
    }
    ```
  </Tab>

  <Tab title="React Native">
    <Tabs>
      <Tab title="New Runtime (Recommended)">
        Use the specific hooks for each property type to get and set property values:

        - `useRiveBoolean`: Read/write boolean properties
        - `useRiveString`: Read/write string properties
        - `useRiveNumber`: Read/write number properties
        - `useRiveColor`: Read/write color properties with hex string or RGBA support
        - `useRiveEnum`: Read/write enum properties
        - `useRiveTrigger`: Fire trigger events with optional callbacks

        These hooks return the current `value`, a setter function (`setValue` or `trigger`), and an `error` if the property is not found.

        <Note>
          The `setValue` function allows you to pass a function that receives the previous value, similar to React's `setState` pattern. This is useful when you need to update a value based on its current state:

          ```tsx
          setValue((v) => (v ?? 0) + 5)
          ```
        </Note>

        ```tsx
        import {
            useRiveFile,
            useViewModelInstance,
            useRiveBoolean,
            useRiveString,
            useRiveNumber,
            useRiveColor,
            useRiveEnum,
            useRiveTrigger,
            RiveView
        } from '@rive-app/react-native';

        const { riveFile } = useRiveFile(require('./my_file.riv'));
        const instance = useViewModelInstance(riveFile);

        // Boolean
        const { value: isActive, setValue: setIsActive, error: boolError } = useRiveBoolean(
            'isToggleOn',
            instance
        );
        // Set: setIsActive(true);

        // String
        const { value: userName, setValue: setUserName, error: stringError } = useRiveString(
            'user/name',
            instance
        );
        // Set: setUserName('Rive');

        // Number
        const { value: score, setValue: setScore, error: numberError } = useRiveNumber(
            'levelScore',
            instance
        );
        // Set: setScore(100);

        // Color (accepts hex string or RiveColor object)
        const { value: themeColor, setValue: setThemeColor, error: colorError } = useRiveColor(
            'ui/themeColor',
            instance
        );
        // Set: setThemeColor('#FF0000FF'); // hex string
        // Or: setThemeColor({ r: 255, g: 0, b: 0, a: 255 }); // RGBA object

        // Enum
        const { value: status, setValue: setStatus, error: enumError } = useRiveEnum(
            'appStatus',
            instance
        );
        // Set: setStatus('loading');

        // Trigger (No value, just a trigger function)
        const { trigger: playEffect, error: triggerError } = useRiveTrigger(
            'playButtonEffect',
            instance,
            {
                // Optional callback to be called when the trigger is fired
                onTrigger: () => {
                    console.log('Trigger Fired!');
                }
            }
        );
        // Trigger: playEffect();

        return (
            <RiveView
                file={riveFile}
                dataBind={instance}
                autoPlay={true}
            />
        );
        ```

        The `value` returned by each hook will update automatically when the property changes in the Rive graphic.
      </Tab>
      <Tab title="Legacy Runtime">
        The following data binding methods are exposed on the `RiveRef` object.

        ```typescript
        setBoolean: (path: string, value: boolean) => void;
        setString: (path: string, value: string) => void;
        setNumber: (path: string, value: number) => void;
        setColor: (path: string, color: RiveRGBA | string) => void;
        setEnum: (path: string, value: string) => void;
        trigger: (path: string) => void;
        ```

        <Note>
          The color property can be set using either a `RiveRGBA` object or a hex string. The hex string should be in the format
          `#RRGGBBAA`, where `RR`, `GG`, `BB`, and `AA` are two-digit hexadecimal values representing the red, green, blue, and
          alpha channels, respectively.

          ```js
          type RiveRGBA = { r: number; g: number; b: number; a: number };
          ```
        </Note>
        Example usage:

        ```typescript
        const [setRiveRef, riveRef] = useRive();
        const setBoolean = () => {
            if (riveRef) {
                riveRef.setBoolean('My Boolean Property', true);
            }
        };
        const setString = () => {
            if (riveRef) {
                riveRef.current.setString('My String Property', 'Hello, Rive');
            }
        };
        const setNumber = () => {
            if (riveRef) {
                riveRef.current.setNumber('My Number Property', 10);
            }
        };
        const setColor = () => {
            if (riveRef) {
                riveRef.setColor('My Color Property', { r: 255, g: 0, b: 0, a: 1 });
                // or
                riveRef.setColor('My Color Property', '#00FF00FF');
            }
        };
        const setEnum = () => {
            if (riveRef) {
                riveRef.setEnum('My Enum Property', 'Option 1');
            }
        };
        const trigger = () => {
            if (riveRef) {
                riveRef.trigger('My Trigger Property');
            }
        };
        ```
      </Tab>
    </Tabs>
  </Tab>

</Tabs>

### Nested Property Paths

View models can have properties of type view model, allowing for arbitrary nesting. You can chain property calls on each instance starting from the root until you get to the property of interest. Alternatively, you can do this through a path parameter, which is similar to a URI in that it is a forward slash delimited list of property names ending in the name of the property of interest.

<Tabs>
  <Tab title="Web">
    ```typescript
    const rive = new rive.Rive({
        autoBind: true,
        onLoad: () => {
            // Access the current instance that was auto-bound
            let vmi = rive.viewModelInstance;

            const nestedNumberByChain = vmi
                .viewModel("My Nested View Model")
                .viewModel("My Second Nested VM")
                .number("My Nested Number");

            const nestedNumberByPath = vmi.number("My Nested View Model/My Second Nested VM/My Nested Number");
        }
    });
    ```
  </Tab>

  <Tab title="React">
    Access nested properties by providing the full path (separated by `/`) as the first argument to the property hooks.

    ```typescript
    import { useViewModelInstanceString, useViewModelInstanceNumber } from '@rive-app/react-webgl2';

    // Accessing 'settings/theme/name' (String)
    const { value: themeName, setValue: setThemeName } = useViewModelInstanceString(
        'settings/theme/name',
        viewModelInstance
    );

    // Accessing 'settings/volume' (Number)
    const { value: volume, setValue: setVolume } = useViewModelInstanceNumber(
        'settings/volume',
        viewModelInstance
    );

    console.log('Current theme:', themeName);
    // setThemeName('Dark Mode');
    // setVolume(80);
    ```
  </Tab>

  <Tab title="Apple">
    <Tabs>
        <Tab title={Apple.currentRuntimeName}>
        Property types are no longer reference types, and require the name or full path to a property when initializing the property value type. There is no longer an API to chain nested properties.

        See [Properties](#properties) for usage details.
        </Tab>
        <Tab title={Apple.legacyRuntimeName}>
            ```swift
            let riveViewModel = RiveViewModel(...)

            var viewModelInstance: RiveDataBindingViewModel.Instance!

            // You can get the view model instance when enabling auto binding
            riveViewModel.riveModel?.enableAutoBind { instance in
                // Store a reference to instance
                viewModelInstance = instance
            }

            // Alternatively, you can create a view model instance manually
            viewModelInstance = riveViewModel.riveModel!.riveFile.viewModelNamed("...")!.createDefaultInstance()!

            let nestedNumberByChain = instance
                                        .viewModelInstanceProperty(fromPath: "Nested View Model")
                                        .viewModelInstanceProperty(fromPath: "Another Nested View Model")
                                        .numberProperty(fromPath: "Number")

            let nestedNumberByPath = instance.numberProperty(fromPath: "Nested View Model/Another Nested View Model/Number")
            ```
        </Tab>
    </Tabs>
  </Tab>

  <Tab title="Android">
    <Tabs>
      <Tab title="Compose">
        ```kotlin
        val parent = rememberViewModelInstance(riveFile, ViewModelSource.Named("Parent VM").namedInstance("Parent"))

        // Using references
        val child = rememberViewModelInstance(riveFile, ViewModelInstanceSource.Reference(parent, "Child"))
        val nestedNumber = child.numberPropertyFlow("My Nested Number").collectAsState(0f)

        // Or using paths
        val nestedNumber = parent.numberPropertyFlow("Child/My Nested Number").collectAsState(0f)
        ```
      </Tab>
      <Tab title="Legacy">
        ```kotlin
        val vm = view.controller.file?.getViewModelByName("My View Model")!!
        val vmi = vm.createInstanceFromName("My Instance")

        val nestedNumberByChain = vmi
            .getInstanceProperty("My Nested View Model")
            .getInstanceProperty("My Second Nested VM")
            .getNumberProperty("My Nested Number")

        val nestedNumberByPath = vmi
            .getNumberProperty("My Nested View Model/My Second Nested VM/My Nested Number")
        ```
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="Flutter">
    ```dart
    // Get reference to the ViewModel instance
    final vmi = someExistingViewModelInstance;

    final nestedNumberByChain = vmi
        .viewModel("My Nested View Model")!
        .viewModel("My Second Nested VM")!
        .number("My Nested Number");

    final nestedNumberByPath = vmi.number("My Nested View Model/My Second Nested VM/My Nested Number");
    ```
  </Tab>

  <Tab title="Unity">
    ```csharp
    if (riveWidget.Status == WidgetStatus.Loaded)
    {
        var viewModelInstance = riveWidget.StateMachine.ViewModelInstance;

        // Accessing nested view models using chaining
        var nestedNumberByChain = viewModelInstance
            .GetViewModelInstanceProperty("My Nested View Model")
            .GetViewModelInstanceProperty("My Second Nested VM")
            .GetNumberProperty("My Nested Number");

        // Accessing nested properties using path notation
        var nestedNumberByPath = viewModelInstance
            .GetNumberProperty("My Nested View Model/My Second Nested VM/My Nested Number");


    }
    ```
  </Tab>

  <Tab title="React Native">
    <Tabs>
      <Tab title="New Runtime (Recommended)">
        Access nested properties by providing the full path (separated by `/`) as the first argument to the property hooks.

        ```tsx
        import { useRiveString, useRiveNumber, useRiveFile, useViewModelInstance } from '@rive-app/react-native';

        const { riveFile } = useRiveFile(require('./my_file.riv'));
        const instance = useViewModelInstance(riveFile);

        // Accessing 'settings/theme/name' (String)
        const { value: themeName, setValue: setThemeName } = useRiveString(
            'settings/theme/name',
            instance
        );

        // Accessing 'settings/volume' (Number)
        const { value: volume, setValue: setVolume } = useRiveNumber(
            'settings/volume',
            instance
        );

        console.log('Current theme:', themeName);
        // setThemeName('Dark Mode');
        // setVolume(80);
        ```

        <Info>
          The Rive React Native runtime does not yet support accessing a ViewModel property directly, to be able to do the chain notation.
        </Info>
      </Tab>
      <Tab title="Legacy Runtime">
        <Warning>
          The Rive React Native runtime does not support accessing nested properties using the chain notation.
          But you can access nested properties using the path notation.
        </Warning>
        ```js
        const [setRiveRef, riveRef] = useRive();
        const nestedNumberByPath = useRiveNumber(riveRef, 'My Nested View Model/My Second Nested VM/My Nested Number');
        useEffect(() => {
            if (nestedNumberByPath) {
                nestedNumberByPath.setValue(10);
            }
        }, [nestedNumberByPath]);
        ```
      </Tab>
    </Tabs>
  </Tab>

</Tabs>

### Observability

You can observe changes over time to property values, either by using listeners or a platform equivalent method. Once observed, you will be notified when the property changes are applied by a state machine advance, whether that is a new value that has been explicitly set or if the value was updated as a result of a binding. Observing trigger properties is an alternative method to receive events from the editor, as compared to [Rive Events](/runtimes/rive-events).

<Tabs>
  <Tab title="Web">
    Adding an observer to a property is done by calling the `on` method on the property.

    ```typescript
    public on(callback: EventCallback)
    ```

    The observer can be removed by calling the `off` method on the property and passing the callback function. Alternatively, you can call `off()` without any arguments to remove all observers.

    ```typescript
    public off(callback?: EventCallback)
    ```

    Example:

    ```typescript
    const rive = new rive.Rive({
        autoBind: true,
        onLoad: () => {
            // Access the current instance that was auto-bound
            let vmi = rive.viewModelInstance;
            const numberProperty = vmi.number("My Number Property");
            // Observe
            numberProperty.on((event) => {
                console.log(event.data);
            });
            // Remove all listener when done
            numberProperty.off();
        }
    });
    ```
  </Tab>

  <Tab title="React">
    The React hooks handle observability automatically. When a property's value changes within the Rive instance (either because you set it via a hook or due to an internal binding), the `value` returned by the corresponding hook (e.g., `useViewModelInstanceString`) updates. This state change triggers a re-render of your React component, allowing you to react to the new value.

    For Triggers, you can provide an `onTrigger` callback directly to the `useViewModelInstanceTrigger` hook, which fires when the trigger is activated in the Rive instance.

    ```typescript
    import { useViewModelInstanceTrigger } from '@rive-app/react-webgl2';

    // Assuming viewModelInstance is available
    const { trigger } = useViewModelInstanceTrigger(
        'showPopup',
        viewModelInstance,
        {
            onTrigger: () => {
                console.log('Show Popup Trigger Fired!');
                // Show your popup UI
            }
        }
    );
    ```
  </Tab>

  <Tab title="Apple">
    <Tabs>
        <Tab title={Apple.currentRuntimeName}>
          Property listeners utilize Swift Concurrency's async throwing stream API. If a property returns a value, you can listen to its changes by calling the `valueStream(of:)` method on a `ViewModelInstance` object.

          ```swift
          let file: File = ...
          let viewModelInstance = try await file.createViewModelInstance(...)
          let stringProperty = StringProperty(path: "path/to/string")
          let valueStream = viewModelInstance.valueStream(of: stringProperty)
          do {
              for try await value in valueStream {
                  print(value)
              }
          } catch let error as ViewModelInstanceError {
              // The thrown error should always be a ViewModelInstanceError type
              print(error)
          } catch {
              print(error)
          }
          ```

          For triggers, you can listen to them by calling the `stream(of:)` method on a `ViewModelInstance` object. This returns a stream of `Void` values, which can be ignored.

          ```swift
          let file: File = ...
          let viewModelInstance = try await file.createViewModelInstance(...)
          let triggerProperty = TriggerProperty(path: "path/to/trigger")
          let triggerStream = viewModelInstance.stream(of: triggerProperty)
          do {
              for try await _ in triggerStream {
                  print("Trigger fired!")
              }
          } catch let error as ViewModelInstanceError {
              // The thrown error should always be a ViewModelInstanceError type
              print(error)
          } catch {
              print(error)
          }
          ```
        </Tab>
        <Tab title={Apple.legacyRuntimeName}>
            ```swift
            let riveViewModel = RiveViewModel(...)

            var viewModelInstance: RiveDataBindingViewModel.Instance!

            // You can get the view model instance when enabling auto binding
            riveViewModel.riveModel?.enableAutoBind { instance in
                // Store a reference to instance
                viewModelInstance = instance
            }

            // Alternatively, you can create a view model instance manually
            viewModelInstance = riveViewModel.riveModel!.riveFile.viewModelNamed("...")!.createDefaultInstance()!

            // Get the string property
            let stringProperty = instance.stringProperty(fromPath: "...")!

            // Add a listener
            let listener = stringProperty.addListener { newValue in
                print(newValue)
            }

            // Remove a listener, where listener is the return value of addListener
            stringProperty.removeListener(listener)

            // Trigger properties can also be listened to for when they are triggered
            instance.triggerProperty(fromPath: "...")!.addListener {
                print("Triggered!")
            }
            ```
        </Tab>
    </Tabs>
  </Tab>

  <Tab title="Android">
    <Tabs>
      <Tab title="Compose">
        Observability is the default behavior when using the Compose API with Kotlin Flows. When you collect a property's flow, you will receive updates whenever the property's value changes.

        ```kotlin
        val vmi = rememberViewModelInstance(...)
        val numberPropertyFlow = vmi.numberPropertyFlow("My Number Property").collectAsState(0f)
        ```
      </Tab>
      <Tab title="Legacy">
        ```kotlin
        val vm = view.controller.file?.getViewModelByName("My View Model")!!
        val vmi = vm.createInstanceFromName("My Instance")

        val numberProperty = vmi.getNumberProperty("My Number Property")
        // Observe
        lifecycleScope.launch {
            numberProperty.valueFlow.collect { value ->
                Log.i("MyActivity", "Value: $value")
            }
        }
        // Or collect in Compose
        val numberValue by numberProperty.valueFlow.collectAsState(0f) // 0 as the initial value while waiting for the first value
        ```
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="Flutter">
    ```dart
    // Get reference to the ViewModel instance
    final vmi = someExistingViewModelInstance;

    final numberProperty = vmi.number("My Number Property")!;
    // Get
    final numberValue = numberProperty.value;

    // Set
    numberProperty.value = 10;

    // Observe
    void onNumberChange(double value) {
        print("Number changed to: $value");
    }
    numberProperty.addListener(onNumberChange);

    // Remove listener when done
    numberProperty.removeListener(onNumberChange);

    // Alternatively, clear all listeners
    numberProperty.clearListeners();

    // Dispose of the property to clear up resources when you're no longer using it
    // This will call `clearListeners()` internally.
    numberProperty.dispose();
    ```
  </Tab>

  <Tab title="Unity">
    ```csharp
    private ViewModelInstanceNumberProperty numberProperty;
    private ViewModelInstanceStringProperty stringProperty;
    private ViewModelInstanceBooleanProperty boolProperty;
    private ViewModelInstanceColorProperty colorProperty;
    private ViewModelInstanceEnumProperty enumProperty;
    private ViewModelInstanceTriggerProperty triggerProperty;

    private void OnEnable()
    {
        riveWidget.OnWidgetStatusChanged += HandleWidgetStatusChanged;
    }

    private void OnDisable()
    {
        riveWidget.OnWidgetStatusChanged -= HandleWidgetStatusChanged;
    }

    private void HandleWidgetStatusChanged()
    {
        if (riveWidget.Status == WidgetStatus.Loaded)
        {
            ViewModelInstance viewModelInstance = riveWidget.StateMachine.ViewModelInstance;

            // Add listeners to properties
            numberProperty = viewModelInstance.GetNumberProperty("count");
            numberProperty.OnValueChanged += OnNumberPropertyChanged;

            stringProperty = viewModelInstance.GetStringProperty("title");
            stringProperty.OnValueChanged += OnStringPropertyChanged;

            boolProperty = viewModelInstance.GetBooleanProperty("isActive");
            boolProperty.OnValueChanged += OnBoolPropertyChanged;

            colorProperty = viewModelInstance.GetColorProperty("backgroundColor");
            colorProperty.OnValueChanged += OnColorPropertyChanged;

            enumProperty = viewModelInstance.GetEnumProperty("category");
            enumProperty.OnValueChanged += OnEnumPropertyChanged;

            triggerProperty = viewModelInstance.GetTriggerProperty("onSubmit");
            triggerProperty.OnTriggered += OnTriggerPropertyFired;


        }
    }

    private void OnNumberPropertyChanged(float newValue)
    {
        Debug.Log($"Number changed to: {newValue}");
    }

    private void OnStringPropertyChanged(string newValue)
    {
        Debug.Log($"String changed to: {newValue}");
    }

    private void OnBoolPropertyChanged(bool newValue)
    {
        Debug.Log($"Boolean changed to: {newValue}");
    }

    private void OnColorPropertyChanged(UnityEngine.Color newValue)
    {
        Debug.Log($"Color changed to: {ColorUtility.ToHtmlStringRGBA(newValue)}");
    }

    private void OnEnumPropertyChanged(string newValue)
    {
        Debug.Log($"Enum changed to: {newValue}");
    }

    private void OnTriggerPropertyFired()
    {
        Debug.Log("Trigger fired!");
    }

    private void OnDestroy()
    {
        // You should remove listeners when no longer needed,
        numberProperty.OnValueChanged -= OnNumberPropertyChanged;
        stringProperty.OnValueChanged -= OnStringPropertyChanged;
        boolProperty.OnValueChanged -= OnBoolPropertyChanged;
        colorProperty.OnValueChanged -= OnColorPropertyChanged;
        enumProperty.OnValueChanged -= OnEnumPropertyChanged;
        triggerProperty.OnTriggered -= OnTriggerPropertyFired;
    }
    ```
  </Tab>

  <Tab title="React Native">
    <Tabs>
      <Tab title="New Runtime (Recommended)">
        Values are observed automatically through hooks. When a property's value changes within the Rive instance (either because you set it via a hook or due to an internal binding), the `value` returned by the corresponding hook updates. This state change triggers a re-render of your React component, allowing you to react to the new value.

        For Triggers, you can provide an `onTrigger` callback directly to the `useRiveTrigger` hook, which fires when the trigger is activated in the Rive instance.

        ```tsx
        import {
            useRiveFile,
            useViewModelInstance,
            useRiveBoolean,
            useRiveString,
            useRiveNumber,
            useRiveColor,
            useRiveEnum,
            useRiveTrigger,
            useEffect
        } from '@rive-app/react-native';

        const { riveFile } = useRiveFile(require('./my_file.riv'));
        const instance = useViewModelInstance(riveFile);

        const { value: boolValue, setValue: setBoolValue } = useRiveBoolean('My Boolean Property', instance);
        const { value: stringValue, setValue: setStringValue } = useRiveString('My String Property', instance);
        const { value: numberValue, setValue: setNumberValue } = useRiveNumber('My Number Property', instance);
        const { value: colorValue, setValue: setColorValue } = useRiveColor('My Color Property', instance);
        const { value: enumValue, setValue: setEnumValue } = useRiveEnum('My Enum Property', instance);
        const { trigger: triggerButton } = useRiveTrigger('My Trigger Property', instance, {
            onTrigger: () => {
                console.log('Trigger fired');
            }
        });

        useEffect(() => {
            if (numberValue !== undefined) {
                console.log('numberValue changed:', numberValue);
            }
        }, [numberValue]);

        const handleButtonPress = () => {
            triggerButton();
        };
        ```

        <Note>
          The `useRiveTrigger` hook returns a `trigger` function that can be called to fire the trigger. This hook accepts an optional `onTrigger` callback in its third parameter that will be executed when the trigger is fired.
        </Note>
      </Tab>
      <Tab title="Legacy Runtime">
        Values are observed through hooks.

        ```typescript
        const [setRiveRef, riveRef] = useRive();
        const [boolValue, setBoolValue] = useRiveBoolean(riveRef, 'My Boolean Property');
        const [stringValue, setStringValue] = useRiveString(riveRef, 'My String Property');
        const [numberValue, setNumberValue] = useRiveNumber(riveRef, 'My Number Property');
        const [colorValue, setColorValue] = useRiveColor(riveRef, 'My Color Property');
        const [enumValue, setEnumValue] = useRiveEnum(riveRef, 'My Enum Property');
        const triggerButton = useRiveTrigger(riveRef, 'My Trigger Property', () => {
            console.log('Trigger fired');
        });

        useEffect(() => {
            if (numberValue !== undefined) {
                console.log('numberValue changed:', numberValue);
            }
        }, [numberValue]);

        const handleButtonPress = () => {
            if (triggerButton) {
                triggerButton();
            }
        };
        ```

        <Note>
          The `useRiveTrigger` hook does not return a value, but instead takes a callback function as its third argument.
          This callback will be executed when the trigger is fired.
        </Note>
      </Tab>
    </Tabs>
  </Tab>

</Tabs>

### Images

Image properties let you set and replace raster images at runtime, with each instance of the image managed independently. For example, you could build an avatar creator and dynamically update features — like swapping out a hat — by setting a view model's image property.

<Demos examples={['dataBindingImages']}  />
<Tabs>
  <Tab title="Web">
    ```js
    const randomImageAsset = (imageProperty) => {
        fetch("https://picsum.photos/300/500").then(async (res) => {
            // Decode the image from the response. This object is used to set the image property.
            const image = await rive.decodeImage(
                new Uint8Array(await res.arrayBuffer())
            );
            imageProperty.value = image;
            // Rive will automatically clean this up. But it's good practice to dispose this manually
            // after you have already set the decoded image. Don't call `unref` if you intend
            // to use the decoded asset again.
            image.unref();
        });
    };

    const rive = new rive.Rive({
        autoBind: true,
        onLoad: () => {
            // Access the current instance that was auto-bound
            let vmi = rive.viewModelInstance;

            // Get the image property by name
            var imageProperty = vmi.image("bound_image");

            // Load random image
            randomImageAsset(imageProperty);

            // Clear the image to render nothing
            imageProperty.value = null;
        }
    });
    ```
  </Tab>

  <Tab title="React">
    Use the `useViewModelInstanceImage` hook to set image properties on view model instances.

    ```typescript
    import { useRive, useViewModel, useViewModelInstance, useViewModelInstanceImage } from '@rive-app/react-webgl2';

    const { rive, RiveComponent } = useRive({
        src: 'your_file.riv',
        artboard: 'MyArtboard',
        stateMachine: 'MyStateMachine',
        autoBind: false,
        // ... other options
    });

    const viewModel = useViewModel(rive, { name: 'MyViewModel' });
    const viewModelInstance = useViewModelInstance(viewModel, { rive });

    // Get the image property setter
    const { setValue: setImage } = useViewModelInstanceImage(
        'profileImage', // Property path
        viewModelInstance
    );

    // Load and set a random image
    const loadRandomImage = async () => {
        if (!setImage) return;

        try {
            const imageUrl = 'https://picsum.photos/300/500';
            const response = await fetch(imageUrl);
            const imageBuffer = await response.arrayBuffer();

            // Decode the image from the response
            const decodedImage = await decodeImage(new Uint8Array(imageBuffer));
            setImage(decodedImage);

            // Clean up the decoded image
            decodedImage.unref();
        } catch (error) {
            console.error('Failed to load image:', error);
        }
    };

    // Clear the image
    const clearImage = () => {
        if (setImage) {
            setImage(null);
        }
    };
    ```
  </Tab>

  <Tab title="Apple">
    <Tabs>
        <Tab title={Apple.currentRuntimeName}>
            To set an image, you first need to decode an image from a `Worker`. This has to be the `Worker` that was used when initializing a `File`, from which you are setting the image property of a view model instance.

            ```swift
            let worker = Worker()
            let file = try await File(source: ..., worker: worker)
            let viewModelInstance = file.createViewModelInstance(...)
            let imageProperty = ImageProperty(path: "path/to/image")
            let imageData: Data = ...
            let image = try await decodeImage(from: imageData)
            viewModelInstance.setValue(of: imageProperty, to: image)
            ```
        </Tab>
        <Tab title={Apple.legacyRuntimeName}>
            ```swift
            let riveViewModel = RiveViewModel(...)

            var viewModelInstance: RiveDataBindingViewModel.Instance!

            // You can get the view model instance when enabling auto binding
            riveViewModel.riveModel?.enableAutoBind { instance in
                // Store a reference to instance
                viewModelInstance = instance
            }

            // Alternatively, you can create a view model instance manually
            viewModelInstance = riveViewModel.riveModel!.riveFile.viewModelNamed("...")!.createDefaultInstance()!

            // Create a RiveRenderImage from data
            let data = Data(...)
            var image = RiveRenderImage(data: data)! // This can return nil if the data is not a valid image

            // Or, create a RiveRenderImage from a UIImage
            image = RiveRenderImage(image: UIImage(named: "my_image")!, format: .png)! // This can return nil if the image is not a valid jpg or png image

            let imageProperty = viewModelInstance.imageProperty(fromPath: "image")!

            // Once you have your data binding view model instance, you can set the image property value
            imageProperty.setValue(image)

            // You can also pass nil to clear the image
            imageProperty.setValue(nil)
            ```
        </Tab>
    </Tabs>
  </Tab>

  <Tab title="Android">
    <Tabs>
      <Tab title="Compose">
        See the [Compose data binding images example](https://github.com/rive-app/rive-android/blob/master/app/src/main/java/app/rive/runtime/example/ComposeImageBindingActivity.kt).

        To set an image property, you need an `ImageAsset`, which can be created from `rememberImage` using a byte array. The below example loads from raw resources into a `Result` for convenience, but you should use the pattern most appropriate for your app.

        ```kotlin
        val imageBytes by produceState<Result<ByteArray>>(Result.Loading) {
            value = withContext(Dispatchers.IO) {
                context.resources.openRawResource(R.raw.my_image)
                    .use { Result.Success(it.readBytes()) }
            }
        }

        // `andThen` maps over the Result to only call the lambda if it's a Success, propagating Failure and Loading otherwise.
        val image = imageBytes.andThen { bytes ->
            rememberImage(riveWorker, bytes)
        }

        // Or combine into one statement
        val image = produceState<Result<ByteArray>>(Result.Loading) {
            value = withContext(Dispatchers.IO) {
                context.resources.openRawResource(R.raw.my_image)
                    .use { Result.Success(it.readBytes()) }
            }
        }.value.andThen { bytes ->
            rememberImage(riveWorker, bytes)
        }

        val vmi = rememberViewModelInstance(riveFile, ViewModelSource.Named("My View Model").defaultInstance())
        LaunchedEffect(vmi, image) {
            when(image) {
                is Result.Failure -> { /* Handle failure to load image */ }
                is Result.Loading -> { /* Handle loading state if needed */ }
                is Result.Success -> {
                    // Set the image property value
                    vmi.setImage("Image property", image.value)
                }
            }
        }
        ```

        If you want to gate the presentation of your Rive content until the image is loaded and only if both are successful, you can use the `zip` convenience function to combine multiple `Result` objects together.

        ```kotlin
        val fileAndImage = riveFile.zip(image)

        when (fileAndImage) {
            is Result.Failure -> { /* Handle failure to load file or image */ }
            is Result.Loading -> { /* Handle loading state if needed */ }
            is Result.Success -> {
                val (riveFile, image) = fileAndImage.value
                // Both riveFile and image are loaded successfully here
                // You can now present your Rive content and set the image property
            }
        }
        ```

        For more information on image assets, see [Loading Assets](./loading-assets).
      </Tab>
      <Tab title="Legacy">
        ```kotlin
        // Load image from the assets folder.
        val imageBytes = context.resources.openRawResource(R.raw.my_image).use { stream ->
          stream.readBytes()
        }

        val vmi = it.stateMachines.first().viewModelInstance!!

        // Replace image property in view model instance with new image.
        val riveImage = RiveRenderImage.fromEncoded(imageBytes)
        vmi.getImageProperty("Image property").set(riveImage)
        ```
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="Flutter">
    <Info>
      See the [Flutter data binding images example](https://github.com/rive-app/rive-flutter/blob/master/example/lib/examples/databinding_images.dart).
    </Info>
    ```dart
    // Access the image property by path on a ViewModelInstance object
    final imageProperty = viewModelInstance.image('my_image')!; // image property named "my_image"

    // Create a RenderImage
    final renderImage = await Factory.rive.decodeImage(bytes); // use `Factory.flutter` if you're using the Flutter renderer

    // If the image is valid, update the image property value
    if (renderImage != null) {
        imageProperty.value = renderImage;
    }

    // You can also set the image property to null to clear it
    imageProperty.value = null;
    ```
  </Tab>

  <Tab title="Unity">
    ```csharp
    [SerializeField] private ImageOutOfBandAsset m_lightImageAsset;
    [SerializeField] private ImageOutOfBandAsset m_darkImageAsset;

    private ViewModelInstanceImageProperty imageProperty;
    private bool isDarkMode = false;

    private void OnEnable()
    {
        riveWidget.OnWidgetStatusChanged += HandleWidgetStatusChanged;
    }

    private void OnDisable()
    {
        riveWidget.OnWidgetStatusChanged -= HandleWidgetStatusChanged;
    }

    private void HandleWidgetStatusChanged()
    {
        if (riveWidget.Status == WidgetStatus.Loaded)
        {
            m_lightImageAsset.Load();
            m_darkImageAsset.Load();
            ViewModelInstance viewModelInstance = riveWidget.StateMachine.ViewModelInstance;

            // Get the image property by name
            imageProperty = viewModelInstance.GetImageProperty("profileImage");
            // or alternatively:
            // imageProperty = viewModelInstance.GetProperty<ViewModelInstanceImageProperty>("profileImage");

            // Set up change callback
            imageProperty.OnValueChanged += OnImageChanged;

            // Set initial image (light mode)
            imageProperty.Value = m_lightImageAsset;
        }
    }

    private void OnImageChanged()
    {
        Debug.Log("Image updated!");
    }

    // Example method to toggle between light and dark mode images
    public void ToggleTheme()
    {
        if (imageProperty != null)
        {
            isDarkMode = !isDarkMode;
            imageProperty.Value = isDarkMode ? m_darkImageAsset : m_lightImageAsset;
        }
    }

    // Example method to clear the image
    public void ClearImage()
    {
        if (imageProperty != null)
        {
            imageProperty.Value = null;
        }
    }

    private void OnDestroy()
    {
        m_lightImageAsset.Unload();
        m_darkImageAsset.Unload();

        // Remove the event listener
        if (imageProperty != null)
        {
            imageProperty.OnValueChanged -= OnImageChanged;
        }
    }
    ```

    For a demo of image data binding in Unity, see the **Image Data Binding** scene in the [Rive Unity Examples repository](https://github.com/rive-app/rive-unity-examples).
  </Tab>

  <Tab title="React Native">
    <Tabs>
      <Tab title="New Runtime (Recommended)">
        Image properties can be set using the `imageProperty` method on a `ViewModelInstance` and the `RiveImages` utility for loading images.

        ```tsx
        import {
            useRive,
            useRiveFile,
            useViewModelInstance,
            RiveView,
            RiveImages,
            type RiveViewRef
        } from '@rive-app/react-native';
        import { useRef } from 'react';

        const { riveViewRef, setHybridRef } = useRive();
        const { riveFile } = useRiveFile(require('./my_file.riv'));
        const instance = useViewModelInstance(riveFile);
        const riveViewRef = useRef<RiveViewRef>(undefined);

        const handleLoadImage = async () => {
            if (!riveViewRef) return;

            const vmi = riveViewRef.getViewModelInstance();
            if (!vmi) return;

            const imgProp = vmi.imageProperty('imageValue');
            if (!imgProp) return;

            // Load image from URL
            const riveImage = await RiveImages.loadFromURLAsync(
                'https://picsum.photos/id/372/500/500'
            );
            imgProp.set(riveImage);
            riveViewRef.playIfNeeded();
        };

        return (
            <RiveView
                hybridRef={setHybridRef}
                file={riveFile}
                dataBind={instance}
                autoPlay={true}
            />
        );
        ```

        You can also add listeners to image properties:

        ```tsx
        const imgProp = vmi.imageProperty('imageValue');
        if (imgProp) {
            imgProp.addListener(() => {
                console.log('Image property changed!');
            });
        }
        ```

        Other image loading options on `RiveImages`:
        ```ts
          /**
          * Load an image from a bundled resource
          * @param resource The resource name (e.g., "image.png")
          * @returns A promise that resolves to the loaded RiveImage
          */
          loadFromResourceAsync(resource: string): Promise<RiveImage>;

          /**
          * Load an image from raw bytes
          * @param bytes The image data as an ArrayBuffer
          * @returns A promise that resolves to the loaded RiveImage
          */
          loadFromBytesAsync(bytes: ArrayBuffer): Promise<RiveImage>;
        ```
      </Tab>
      <Tab title="Legacy Runtime">
        <Warning>
          Image data binding is not supported on the legacy runtime.
        </Warning>
      </Tab>
    </Tabs>
  </Tab>

</Tabs>

### Lists

List properties let you manage a dynamic set of view model instances at runtime. For example, you can build a TODO app where users can add and remove tasks in a scrollable Layout.

See the [Editor section](/editor/data-binding/lists) on creating data bound lists.

A single list property can include different view model types, with each view model tied to its own Component, making it easy to populate a list with a varity of Component instances.

With list properties, you can:

- Add a new view model instance (optionally at an index)
- Remove an existing view model instance (optionally by index)
- Swap two view model instances by index
- Get the size of a list

For more information on list properties, see the [Data Binding List Property](/editor/data-binding/lists#view-model-list-property) editor documentation.

<Demos examples={['dataBindingLists']}  />
<Tabs>
  <Tab title="Web">
    ```javascript
    const rive = new rive.Rive({
        autoBind: true,
        onLoad: () => {
            // Access the current instance that was auto-bound
            let vmi = rive.viewModelInstance;

            // Get the list property by name
            var list = vmi.list("todos");
            console.log("length: ", list.length);

            // Get the view model
            var todoItemVM = riveInstance.viewModelByName("TodoItem");

            // Create a blank instance from the view model.
            // Do this for each new item you want to add.
            var myTodo = todoItemVM.instance();
            myTodo.string("description").value = "Buy groceries";

            // Add the newly created instance to the list
            list.addInstance(myTodo);

            // Remove a specific instance from the list
            list.removeInstance(myTodo);

            // Swap two instances in the list at index 0 and 1
            list.swap(0, 1);

            // Remove instance at index 0
            list.removeInstanceAt(0);
        }
    });
    ```
  </Tab>

  <Tab title="React">
    Use the `useViewModelInstanceList` hook to manage list properties on view model instances.

    ```typescript
    import { useRive, useViewModel, useViewModelInstance, useViewModelInstanceList } from '@rive-app/react-webgl2';

    const { rive, RiveComponent } = useRive({
        src: 'your_file.riv',
        artboard: 'MyArtboard',
        stateMachine: 'MyStateMachine',
        autoBind: false,
        // ... other options
    });

    const viewModel = useViewModel(rive, { name: 'MyViewModel' });
    const viewModelInstance = useViewModelInstance(viewModel, { rive });

    // Get the list property with manipulation functions
    const {
        length,
        addInstance,
        addInstanceAt,
        removeInstance,
        removeInstanceAt,
        getInstanceAt,
        swap
    } = useViewModelInstanceList('todos', viewModelInstance);

    // Add a new todo item
    const handleAddItem = () => {
        const todoItemViewModel = rive?.viewModelByName?.('TodoItem');
        if (todoItemViewModel) {
            const newTodoItem = todoItemViewModel.instance?.();
            if (newTodoItem) {
                // Set some initial values
                newTodoItem.string('description').value = 'Buy groceries';
                addInstance(newTodoItem);
            }
        }
    };

    // Insert item at specific index
    const handleInsertItem = () => {
        const todoItemViewModel = rive?.viewModelByName?.('TodoItem');
        if (todoItemViewModel) {
            const newTodoItem = todoItemViewModel.instance?.();
            if (newTodoItem) {
                addInstanceAt(newTodoItem, 0); // Insert at beginning
            }
        }
    };

    // Remove first item by instance
    const handleRemoveFirst = () => {
        const firstInstance = getInstanceAt(0);
        if (firstInstance) {
            removeInstance(firstInstance);
        }
    };

    // Remove item by index
    const handleRemoveAt = () => {
        if (length > 0) {
            removeInstanceAt(0);
        }
    };

    // Swap two items
    const handleSwap = () => {
        if (length >= 2) {
            swap(0, 1);
        }
    };

    console.log(`List has ${length} items`);
    ```
  </Tab>

  <Tab title="Apple">
    <Tabs>
        <Tab title={Apple.currentRuntimeName}>
            ```swift
            let file: File = ...
            let viewModelInstance = try await file.createViewModelInstance(...)
            let listProperty = ListProperty(path: "path/to/list")

            let size = try await viewModelInstance.size(of: listProperty)

            // Result: [newInstance]
            let newInstance = try await file.createViewModelInstance(...)
            viewModelInstance.appendInstance(newInstance, to: listProperty)

            // Result: [insertedInstance, newInstance]
            let insertedInstance = try await file.createViewModelInstance(...)
            viewModelInstance.insertInstance(instance, to: listProperty, at: 0)

            // Result: [newInstance, insertedInstance]
            viewModelInstance.swapInstance(atIndex: 0, withIndex: 1, in: listProperty)

            // Result: [newInstance]
            viewModelInstance.removeInstance(at: 1, from: listProperty)

            // Result: newInstance
            let _ = viewModelInstance.value(of: listProperty, at: 0)

            // Result: []
            viewModelInstance.removeInstance(newInstance, from: listProperty)

            // Result: 0
            let size = try await viewModelInstance.size(of: listProperty)
            ```
        </Tab>
        <Tab title={Apple.legacyRuntimeName}>
            ```swift
            let listProperty = viewModelInstance.listProperty(fromPath: "list")!

            // Create a new view model instance and add it to the end of the list
            let firstInstance = viewModel.createInstanceByName("First Instance")!
            listProperty.add(firstInstance)

            // Create a new view model instance and add it to the beginning of the list
            let secondInstance = myViewModel.createInstanceByName("Second Instance")!
            listProperty.add(secondInstance, atIndex: 0)

            // Swap the first and second instances
            listProperty.swapInstance(atIndex: 0, withInstanceAtIndex: 1)

            // Remove both instances
            listProperty.removeInstance(secondInstance)
            listProperty.removeInstance(atIndex: 0)

            // Get and print the size of the list
            print(listProperty.size) // Prints 0
            ```
        </Tab>
    </Tabs>
  </Tab>

  <Tab title="Android">
    <Tabs>
      <Tab title="Compose">
        See the [Compose data binding lists example](https://github.com/rive-app/rive-android/blob/master/app/src/main/java/app/rive/runtime/example/ComposeListActivity.kt).

        ```kotlin
        val mainVMI = rememberViewModelInstance(riveFile)
        val newListItem = rememberViewModelInstance(riveFile, ViewModelSource.Named("My Item VM").namedInstance("My List Item"))
        LaunchedEffect(mainVMI, newListItem) {
            val listProperty = "My List"

            // Add new item to the end of the list
            mainVMI.appendToList(listProperty, newListItem)
            // Insert new item at index 0
            mainVMI.insertToListAtIndex(listProperty, 0, newListItem)

            // Swap items at index 0 and 1
            mainVMI.swapListItems(listProperty, 0, 1)

            // Remove specific instance
            mainVMI.removeFromList(listProperty, newListItem)
            // Remove item at index 0
            mainVMI.removeFromListAtIndex(listProperty, 0)
        }
        ```

        Due to the dynamic nature of lists, you may need to create items within a coroutine rather than ahead of time with `rememberViewModelInstance`. Be aware that adding the same instance multiple times to a list will cause them all to share state, which may not be the desired behavior. Use the following pattern to create new instances as needed.

        ```kotlin
        val mainVMI = rememberViewModelInstance(riveFile)
        LaunchedEffect(mainVMI) {
            val listProperty = "My List"
            // ⚠️ This must be `close`d, which is done here through `AutoCloseable.use`.
            ViewModelInstance.fromFile(
                riveFile,
                ViewModelSource.Named("My Item VM").defaultInstance()
            ).use { item ->
                mainVMI.insertToListAtIndex(listProperty, 0, item)
            }
        }
        ```
      </Tab>
      <Tab title="Legacy">
        ```kotlin
        // Acquire the default view model instance and the list property.
        val vmi = animationView.file!!.firstArtboard.viewModelInstance!!
        val listProperty = vmi.getListProperty("list")

        // Create a view model instance for "First" and "Second" and add them to the list.
        val firstInstance = animationView.file!!.getViewModelByName("My Item VM").createInstanceFromName("First")
        listProperty.add(firstInstance)

        val secondInstance = animationView.file!!.getViewModelByName("My Item VM").createInstanceFromName("Second")
        listProperty.add(secondInstance)

        // Swap the two items in the list.
        listProperty.swap(0, 1)

        // Remove both items from the list.
        listProperty.remove(firstInstance)
        listProperty.removeAt(0)
        ```
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="Flutter">
    The list API in Flutter is designed to be similar to the [List](https://api.dart.dev/dart-core/List-class.html) class in Dart. It doesn't contain the full API spec of that class, but it does provide the most commonly used methods.

    <Warning>
      Working with lists can result in errors ([`RangeError`](https://api.flutter.dev/flutter/dart-core/RangeError-class.html)) being thrown if you try to access an index that is out of bounds, or perform other list operations that are not permitted. Similar to the Dart List API.
    </Warning>
    Access a list property by path on a `ViewModelInstance` object:

    ```dart Access a List property
    final todosProperty = viewModelInstance.list('todos')!; // list property named "todos"
    print(todosProperty.length); // print the length of the list
    ```

    To add an item you first need to create an instance of the view model that you want to add to the list:

    ```dart Create a blank view model instance
    final todoItemVM = riveFile.viewModelByName("TodoItem")!;
    final todoItemInstance = todoItemVM.createInstance()!;
    ```

    You can also create an instance from an existing instance (as exported in the Rive Editor), using:

    - `createDefaultInstance()`
    - `createInstanceByName('exercise')`
    - `createInstanceByIndex(0)`.

    Then add the instance to the list:

    ```dart Add an instance to the list
    todosProperty.add(todoItemInstance);
    ```

    To remove a particular instance from the list, you can use the `remove` method:

    ```dart Remove an instance from the list
    todosProperty.remove(todoItemInstance);
    ```

    Other operations:

    ```dart List operations
    // Remove at index
    todosProperty.removeAt(0); // can throw

    // Insert at index
    todosProperty.insert(0, todoItemInstance); // can throw

    // Swap
    todosProperty.swap(0, 1); // can throw

    // First
    ViewModelInstance todo = todosProperty.first(); // can throw

    // Last
    ViewModelInstance todo = todosProperty.last(); // can throw

    // First or null
    ViewModelInstance? todo todosProperty.firstOrNull(); // will return null if the list is empty

    // Last or null
    ViewModelInstance? todosProperty.lastOrNull(); // will return null if the list is empty

    // Access/set directly by index
    final instance = todosProperty[0]; // can throw
    todosProperty[0] = todoItemInstance; // can throw

    // Instance at index
    todosProperty.instanceAt(2); // can throw

    // Length
    todosProperty.length;
    ```
  </Tab>

  <Tab title="Unity">
    ```csharp
    private ViewModelInstanceListProperty listProperty;

    private void OnEnable()
    {
        riveWidget.OnWidgetStatusChanged += HandleWidgetStatusChanged;
    }

    private void OnDisable()
    {
        riveWidget.OnWidgetStatusChanged -= HandleWidgetStatusChanged;
    }

    private void HandleWidgetStatusChanged()
    {
        if (riveWidget.Status == WidgetStatus.Loaded)
        {
            ViewModelInstance viewModelInstance = riveWidget.StateMachine.ViewModelInstance;

            // Get the list property by name
            listProperty = viewModelInstance.GetListProperty("todos");
            // or alternatively:
            // var listProperty = viewModelInstance.GetProperty<ViewModelInstanceListProperty>("todos");

            Debug.Log($"List count: {listProperty.Count}");

            // Set up change callback
            listProperty.OnChanged += OnListChanged;

            // Get the view model for creating new instances
            var todoItemVM = riveWidget.File.GetViewModelByName("TodoItem");

            // Create a blank instance from the view model
            var newTodo = todoItemVM.CreateInstance();
            newTodo.GetStringProperty("description").Value = "Buy groceries";

            // Add the newly created instance to the list
            listProperty.Add(newTodo);

            // Insert an instance at a specific index
            var anotherTodo = todoItemVM.CreateInstance();
            listProperty.Insert(anotherTodo, 0); // Insert at beginning

            // Access items by index
            for (int i = 0; i < listProperty.Count; i++)
            {
                var item = listProperty.GetInstanceAt(i);
                Debug.Log($"Item {i}: {item}");
            }

            // Remove a specific instance from the list
            listProperty.Remove(newTodo);

            // Remove instance at index
            listProperty.RemoveAt(0);

            // Swap two instances in the list at index 0 and 1
            if (listProperty.Count > 1)
            {
                listProperty.Swap(0, 1);
            }
        }
    }

    private void OnListChanged()
    {
        Debug.Log("List updated!");
    }

    private void OnDestroy()
    {
        if (listProperty != null)
        {
            listProperty.OnChanged -= OnListChanged;
        }
    }
    ```
  </Tab>

  <Tab title="React Native">
    <Tabs>
      <Tab title="New Runtime (Recommended)">
        Use the `useRiveList` hook to manage list properties on view model instances.

        ```tsx
        import {
            useRiveFile,
            useViewModelInstance,
            useRiveList,
            RiveView
        } from '@rive-app/react-native';

        const { riveFile } = useRiveFile(require('./my_file.riv'));
        const instance = useViewModelInstance(riveFile);

        // Get the list property with manipulation functions
        const {
            length,
            getInstanceAt,
            addInstance,
            addInstanceAt,
            removeInstance,
            removeInstanceAt,
            swap,
            error
        } = useRiveList('todos', instance);

        // Add a new todo item
        const handleAddItem = () => {
            const todoItemViewModel = riveFile?.viewModelByName('TodoItem');
            if (todoItemViewModel) {
                const newTodoItem = todoItemViewModel.createInstance();
                if (newTodoItem) {
                    // Set some initial values
                    newTodoItem.stringProperty('description')?.set('Buy groceries');
                    addInstance(newTodoItem);
                }
            }
        };

        // Insert item at specific index
        const handleInsertItem = () => {
            const todoItemViewModel = riveFile?.viewModelByName('TodoItem');
            if (todoItemViewModel) {
                const newTodoItem = todoItemViewModel.createInstance();
                if (newTodoItem) {
                    addInstanceAt(newTodoItem, 0); // Insert at beginning
                }
            }
        };

        // Remove first item by instance
        const handleRemoveFirst = () => {
            const firstInstance = getInstanceAt(0);
            if (firstInstance) {
                removeInstance(firstInstance);
            }
        };

        // Remove item by index
        const handleRemoveAt = () => {
            if (length > 0) {
                removeInstanceAt(0);
            }
        };

        // Swap two items
        const handleSwap = () => {
            if (length >= 2) {
                swap(0, 1);
            }
        };

        console.log(`List has ${length} items`);

        return (
            <RiveView
                file={riveFile}
                dataBind={instance}
                autoPlay={true}
            />
        );
        ```

      </Tab>
      <Tab title="Legacy Runtime">
        <Warning>
        List data binding is not supported on the legacy runtime.
        </Warning>
      </Tab>
    </Tabs>
  </Tab>

</Tabs>

### Artboards

Artboard properties allows you to swap out entire components at runtime. This is useful for creating modular components that can be reused across different designs or applications, for example:

- Creating a skinning system that supports a large number of variations, such as a character creator where you can swap out different body parts, clothing, and accessories.
- Creating a complex scene that is a composition of various artboards loaded from various different Rive files (drawn to a single canvas/texture/widget).
- Reducing the size (complexity) of a single Rive file by breaking it up into smaller components that can be loaded on demand and swapped in and out as needed.

<Demos examples={["dataBindingArtboards"]} />

<Tabs>
  <Tab title="Web">
    ```typescript
    let artboardProperty = null;
    let characterArtboard = null;

    function attachCharacter() {
        // If the artboard property and the character artboard, both exist, set the artboard
        if (characterArtboard && artboardProperty) {
            artboardProperty.value = characterArtboard;
        }
    }

    const r = new Rive({
        src: "swap_character_main.riv",
        autoplay: true,
        canvas: el,
        autoBind: true,
        layout: new Layout({
            fit: Fit.Layout,
            layoutScaleFactor: 0.5,
        }),
        stateMachines: "State Machine 1",
        onLoad: () => {
            r.resizeDrawingSurfaceToCanvas();

            const vmi = r.viewModelInstance;
            artboardProperty = vmi.artboard("Artboard property");

            attachCharacter();
        },
        onLoadError: () => {
            console.log("error");
        },
    });

    // Load an external artboard
    const assetsFile = new RiveFile({
        src: "swap_character_assets.riv",
        onLoad: () => {
            characterArtboard = assetsFile.getArtboard("Character 1");
            attachCharacter();
        },
        onLoadError: () => {
            console.log("error");
        },
    });
    assetsFile.init();
    ```
  </Tab>

  <Tab title="React">
    Use the `useViewModelInstanceArtboard` hook to set artboard properties on view model instances.

    ```typescript
    import { useRive, useViewModel, useViewModelInstance, useViewModelInstanceArtboard } from '@rive-app/react-webgl2';

    const { rive, RiveComponent } = useRive({
        src: 'your_file.riv',
        artboard: 'MyArtboard',
        stateMachine: 'MyStateMachine',
        autoBind: true,
        // ... other options
    });

    // Get artboard property setters
    const { setValue: setArtboard1 } = useViewModelInstanceArtboard(
        'artboard_1', // Property path
        rive?.viewModelInstance
    );

    const { setValue: setArtboard2 } = useViewModelInstanceArtboard(
        'artboard_2', // Property path
        rive?.viewModelInstance
    );

    // Assign different artboards from the same file
    const handleSetBlueArtboard = () => {
        if (rive) {
            const blueArtboard = rive.getArtboard('ArtboardBlue');
            setArtboard1(blueArtboard);
        }
    };

    const handleSetRedArtboard = () => {
        if (rive) {
            const redArtboard = rive.getArtboard('ArtboardRed');
            setArtboard2(redArtboard);
        }
    };

    const handleSetGreenArtboard = () => {
        if (rive) {
            const greenArtboard = rive.getArtboard('ArtboardGreen');
            setArtboard1(greenArtboard);
        }
    };

    ```
  </Tab>

  <Tab title="Apple">
    <Tabs>
        <Tab title={Apple.currentRuntimeName}>
        ```swift
        let file: File = ...
        let viewModelInstance = try await file.createViewModelInstance(...)
        let artboardProperty = ArtboardProperty(path: "path/to/artboard")
        let artboard = try await file.createArtboard(...)
        viewModelInstance.setValue(of: artboardProperty, to: artboard)
        ```
        </Tab>
        <Tab title={Apple.legacyRuntimeName}>
            Use the `artboardProperty` method on a `RiveDataBindingViewModel.Instance` object to get the artboard property.

            Then use the `setValue` method on the artboard property object to set the new artboard value.

            `setValue` accepts a `RiveBindableArtboard` object, which is a wrapper for an artboard that can be used to set the artboard property value.

            You can get a `RiveBindableArtboard` object by using the `bindableArtboard` methods on a `RiveFile` object.

            ```swift
            let artboardProperty = instance.artboardProperty(fromPath: "Artboard")!

            let components = RiveFile(...)
            let bindableArtboard = components.bindableArtboard(at: 0)!
            let bindableArtboard2 = components.bindableArtboard(withName: "...")!

            artboardProperty.setValue(bindableArtboard)
            ```
        </Tab>
    </Tabs>
  </Tab>

  <Tab title="Android">
    <Tabs>
      <Tab title="Compose">
        See the [Compose data binding artboards example](https://github.com/rive-app/rive-android/blob/master/app/src/main/java/app/rive/runtime/example/ComposeArtboardBindingActivity.kt).

        ```kotlin
        val vmi = rememberViewModelInstance(mainFile)
        val artboard = rememberArtboard(mainFile, "My Artboard")

        LaunchedEffect(vmi, artboard) {
            vmi.setArtboard("My Artboard Property", artboard)
        }
        ```
      </Tab>
      <Tab title="Legacy">
        ```kotlin
        // Acquire the default view model instance and the artboard property.
        val vmi = animationView.file!!.firstArtboard.viewModelInstance!!
        val artboardProperty = vmi.getArtboardProperty("My Artboard Property")

        // Set artboard from same file.
        val localArtboard = animationView.file!!.getArtboard("My Artboard")
        artboardProperty.set(localArtboard)

        // Load external file if needed
        val externalFile = File.load(context.assets, "external_file.riv")

        // Set artboard from external file.
        val externalArtboard = externalFile.getArtboard("My External Artboard")
        artboardProperty.set(externalArtboard)

        // Clean up external file when done
        externalFile.dispose()
        ```
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="Flutter">
    <Info>
      See the [Flutter data binding artboards example](https://github.com/rive-app/rive-flutter/blob/master/example/lib/examples/databinding_artboards.dart).
    </Info>
    Artboard properties work with the `BindableArtboard` class, which is different from the regular `Artboard` class in the package.

    `BindableArtboard` is a runtime wrapper for interacting with artboards through data binding. These instances reference existing artboards in your file, so no additional setup is required in the Rive Editor.

    ```dart
        // Artboard property to bind
        final artboardProp = viewModelInstance.artboard('artboardPropertyName')!;

        // Create a bindable artboard
        final bindableArtboard = riveFile.artboardToBind('artboardName')!;
        artboardProp.value = bindableArtboard;
    ```
  </Tab>

  <Tab title="Unity">
    Artboard properties work with the `BindableArtboard` class, which is different from the regular `Artboard` class in the package.

    `BindableArtboard` is a runtime wrapper for interacting with artboards through data binding. These instances reference existing artboards in your file, so no additional setup is required in the Rive Editor.

    ```csharp
    [SerializeField] private Asset m_externalRiveAsset;

    private ViewModelInstanceArtboardProperty artboardProperty;
    private File externalFile;

    private void OnEnable()
    {
        riveWidget.OnWidgetStatusChanged += HandleWidgetStatusChanged;
    }

    private void OnDisable()
    {
        riveWidget.OnWidgetStatusChanged -= HandleWidgetStatusChanged;
    }

    private void HandleWidgetStatusChanged()
    {
        if (riveWidget.Status == WidgetStatus.Loaded)
        {
            ViewModelInstance viewModelInstance = riveWidget.StateMachine.ViewModelInstance;

            // Get the artboard property by name
            artboardProperty = viewModelInstance.GetArtboardProperty("artboard_1");
            // or alternatively:
            // artboardProperty = viewModelInstance.GetProperty<ViewModelInstanceArtboardProperty>("artboard_1");

            // Set up change callback
            artboardProperty.OnValueChanged += OnArtboardChanged;

            // Set artboard from same file.
            var blueArtboard = riveWidget.File.BindableArtboard("ArtboardBlue");
            artboardProperty.Value = blueArtboard;

            // Load external file if needed
            if (m_externalRiveAsset != null)
            {
                externalFile = File.Load(m_externalRiveAsset);
            }
        }
    }

    private void OnArtboardChanged()
    {
        Debug.Log("Artboard changed");
    }

    // Example method to assign a different artboard from the same file
    public void SwitchToRedArtboard()
    {
        if (artboardProperty != null)
        {
            var redArtboard = riveWidget.File.BindableArtboard("ArtboardRed");
            artboardProperty.Value = redArtboard;
        }
    }

    // Example method to assign an artboard from a different file
    // This is useful for creating modular components that can be reused across different Rive files.
    public void SwitchToExternalArtboard()
    {
        if (artboardProperty != null && externalFile != null)
        {
            var externalArtboard = externalFile.BindableArtboard("SomeArtboard");
            artboardProperty.Value = externalArtboard;
        }
    }

    private void OnDestroy()
    {
        // Clean up external file
        externalFile?.Dispose();

        // Remove the event listener
        if (artboardProperty != null)
        {
            artboardProperty.OnValueChanged -= OnArtboardChanged;
        }
    }
    ```

    ### Using Custom View Model Instances with Bindable Artboards

    You can link a custom `ViewModelInstance` to a bindable artboard, giving you control over the data being used by that artboard.

    To create a bindable artboard with a custom view model instance, use the overload on the `File` instance that contains the artboard: 

    ```csharp
    var file = riveWidget.File;
    var viewModelInstance = file.GetViewModelByName("CharacterData").CreateInstance();
    var bindableArtboard = file.BindableArtboard("FeaturedCharacterCard", viewModelInstance);
    ```

    **Example: Featured Content Slot**

    Imagine you have a home screen with a single "featured" content area that can display different types of promotions. Each content type uses a **different artboard with its own unique data structure**. Your main UI file contains the home screen layout with a featured content slot that you can populate dynamically:

    ```csharp
    private ViewModelInstanceArtboardProperty featuredContentSlot;

    private ViewModelInstance characterData;
    private ViewModelInstance eventData;
    private ViewModelInstance offerData;

    private BindableArtboard featuredCharacter;
    private BindableArtboard limitedEvent;
    private BindableArtboard specialOffer;

    private void HandleWidgetStatusChanged()
    {
        if (riveWidget.Status == WidgetStatus.Loaded)
        {
            ViewModelInstance viewModelInstance = riveWidget.StateMachine.ViewModelInstance;

            // Get the featured content slot from your main UI
            featuredContentSlot = viewModelInstance.GetArtboardProperty("featuredContentSlot");

            // Featured Character has its own unique data structure
            var characterViewModel = riveWidget.File.GetViewModelByName("CharacterData");
            characterData = characterViewModel.CreateInstance();
            var charName = characterData.GetStringProperty("name");
            var charClass = characterData.GetStringProperty("class");
            var attackPower = characterData.GetNumberProperty("attackPower");
            var specialAbility = characterData.GetStringProperty("specialAbility");
            var isUnlocked = characterData.GetBoolProperty("unlocked");
            charName.Value = "Shadowblade";
            charClass.Value = "Assassin";
            attackPower.Value = 92;
            specialAbility.Value = "Phantom Strike";
            isUnlocked.Value = false;

            // Limited-Time Event has its own unique data structure
            var eventViewModel = riveWidget.File.GetViewModelByName("EventData");
            eventData = eventViewModel.CreateInstance();
            var eventTitle = eventData.GetStringProperty("title");
            var eventDescription = eventData.GetStringProperty("description");
            var hoursRemaining = eventData.GetNumberProperty("hoursRemaining");
            var participantCount = eventData.GetNumberProperty("participants");
            var isActive = eventData.GetBoolProperty("active");
            eventTitle.Value = "Dragon Raid Weekend";
            eventDescription.Value = "Team up to defeat the ancient dragon";
            hoursRemaining.Value = 36;
            participantCount.Value = 1247;
            isActive.Value = true;

            // Special Offer has its own unique data structure
            var offerViewModel = riveWidget.File.GetViewModelByName("OfferData");
            offerData = offerViewModel.CreateInstance();
            var offerName = offerData.GetStringProperty("itemName");
            var originalPrice = offerData.GetNumberProperty("originalPrice");
            var discountPercent = offerData.GetNumberProperty("discount");
            var currency = offerData.GetStringProperty("currencyType");
            var timeLeftHours = offerData.GetNumberProperty("expiresInHours");
            offerName.Value = "Legendary Weapon Pack";
            originalPrice.Value = 2999;
            discountPercent.Value = 50;
            currency.Value = "Gems";
            timeLeftHours.Value = 12;

            // Create bindable artboards. Each uses a DIFFERENT artboard with unique design
            featuredCharacter = riveWidget.File.BindableArtboard("FeaturedCharacterCard", characterData);
            limitedEvent = riveWidget.File.BindableArtboard("EventBanner", eventData);
            specialOffer = riveWidget.File.BindableArtboard("OfferCard", offerData);

            // Start by showing the featured character
            featuredContentSlot.Value = featuredCharacter;
        }
    }

    // Switch to showing the limited-time event
    public void ShowLimitedEvent()
    {
        if (featuredContentSlot != null && limitedEvent != null)
        {
            featuredContentSlot.Value = limitedEvent;
        }
    }

    // Switch to showing the special offer
    public void ShowSpecialOffer()
    {
        if (featuredContentSlot != null && specialOffer != null)
        {
            featuredContentSlot.Value = specialOffer;
        }
    }

    // Update event countdown timer
    public void UpdateEventTimer(float deltaTime)
    {
        if (eventData != null)
        {
            var hoursRemaining = eventData.GetNumberProperty("hoursRemaining");
            hoursRemaining.Value -= (deltaTime / 3600f); // Convert seconds to hours
        }
    }

    private void OnDestroy()
    {
        // Clean up view model instances
        characterData?.Dispose();
        eventData?.Dispose();
        offerData?.Dispose();

        // Clean up bindable artboards
        featuredCharacter?.Dispose();
        limitedEvent?.Dispose();
        specialOffer?.Dispose();

        // Remove event listeners if any were added
        if (featuredContentSlot != null)
        {
            featuredContentSlot.OnValueChanged -= OnArtboardChanged;
        }
    }
    ```
  </Tab>

  <Tab title="React Native">
    <Tabs>
      <Tab title="New Runtime (Recommended)">
        <Info>
          See the [React Native data binding artboards example](https://github.com/rive-app/rive-nitro-react-native/blob/main/example/src/pages/DataBindingArtboardsExample.tsx).
        </Info>
        Artboard properties work with the `BindableArtboard` class. Use `getBindableArtboard` on a `RiveFile` to create a bindable reference, then set it on the artboard property.

        ```typescript
        // Get artboard property from view model instance
        const artboardProp = instance.artboardProperty('CharacterArtboard');

        // Create a bindable artboard and set it
        const bindableArtboard = riveFile.getBindableArtboard('Character 1');
        artboardProp?.set(bindableArtboard);
        ```
      </Tab>
      <Tab title="Legacy Runtime">
        <Warning>
          Artboard data binding is not supported on the legacy runtime.
        </Warning>
      </Tab>
    </Tabs>
  </Tab>

</Tabs>

### Enums

Enums properties come in two flavors: system and user-defined. In practice, you will not need to worry about the distinction, but just be aware that system enums are available in any Rive file that binds to an editor-defined enum set, representing options from the editor's dropdowns, where user-defined enums are those defined by a designer in the editor.

Enums are string typed. The Rive file contains a list of enums. Each enum in turn has a name and a list of strings.

<Tabs>
  <Tab title="Web">
    ```typescript
    const rive = new rive.Rive({
        onLoad: () => {
            const enums = rive.enums();

            console.log(enums);
        }
    });
    ```
  </Tab>

  <Tab title="React">
    ```typescript
    const { rive } = useRive({
        src: 'your_file.riv',
        artboard: 'MyArtboard',
        stateMachine: 'MyStateMachine',
        autoBind: true
        // ... other options
    });
    const enums = rive?.enums();
    console.log(enums);
    ```
  </Tab>

  <Tab title="Android">
    <Tabs>
      <Tab title="Compose">
        ```kotlin
        LaunchedEffect(riveFile) {
            val enums = riveFile.getEnums()
            Log.i("RiveEnums", "First enum name: ${enums[0].name}")
        }
        ```
      </Tab>
      <Tab title="Legacy">
        ```kotlin
        val enums = view.controller.file?.enums!!

        val firstEnumName = enums[0].name
        val firstEnumFirstValue = enums[0].values[0]
        ```
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="Flutter">
    ```dart
    // Accesss on a File object
    print("Data enums: ${file.enums}");
    ```
  </Tab>

  <Tab title="Unity">
    ```csharp
    var viewModelInstance = riveWidget.StateMachine.ViewModelInstance;

    // Accessing enums from the file
    var enums = riveWidget.File.ViewModelEnums;
    foreach (var enumType in enums)
    {
        Debug.Log($"Enum: {enumType.Name}");
        foreach (var value in enumType.Values)
        {
            Debug.Log($" - Value: {value}");
        }
    }

    ...
    // Using enum properties
    var enumProperty = viewModelInstance.GetEnumProperty("category");
    Debug.Log($"Current value: {enumProperty.Value}");
    Debug.Log($"Available values: {string.Join(", ", enumProperty.EnumValues)}");
    enumProperty.Value = enumProperty.EnumValues[0]; // Set to first value
    ```
  </Tab>

  <Tab title="React Native">
    <Tabs>
      <Tab title="New Runtime (Recommended)">
        You can access enum properties using the `useRiveEnum` hook. The hook returns the current value and a setter function.

        ```tsx
        import {
            useRiveFile,
            useViewModelInstance,
            useRiveEnum,
            RiveView
        } from '@rive-app/react-native';

        const { riveFile } = useRiveFile(require('./my_file.riv'));
        const instance = useViewModelInstance(riveFile);

        const { value: category, setValue: setCategory, error } = useRiveEnum(
            'category',
            instance
        );

        // Set enum value
        setCategory('option_name');

        return (
            <RiveView
                file={riveFile}
                dataBind={instance}
                autoPlay={true}
            />
        );
        ```

        <Note>
          Retrieving the list of all enums in the file, or accessing all possible values on an Enum, is not yet available.
        </Note>
      </Tab>
      <Tab title="Legacy Runtime">
        <Warning>
          Retrieving the list of enums is not supported on the legacy API.
        </Warning>
      </Tab>
    </Tabs>
  </Tab>

</Tabs>

# Examples

<Tabs>
  <Tab title="Web">
    <YouTube id="y7glxOIFEjg" />
    <YouTube id="1WFtGX2coXM" />
  </Tab>

  <Tab title="React">
    See the `DataBinding` story in the [Rive React repo](https://github.com/rive-app/rive-react) for a demo.
  </Tab>

  <Tab title="Apple">
    See the [Data Binding view](https://github.com/rive-app/rive-ios/blob/main/Example-iOS/Source/Examples/SwiftUI/DataBindingView.swift) in the Example app for a demo.
  </Tab>

  <Tab title="Android">
    <Tabs>
      <Tab title="Compose">
        See the following examples:
        - [Data Binding Overview](https://github.com/rive-app/rive-android/blob/master/app/src/main/java/app/rive/runtime/example/ComposeDataBindingActivity.kt)
        - [Data Binding Images](https://github.com/rive-app/rive-android/blob/master/app/src/main/java/app/rive/runtime/example/ComposeImageBindingActivity.kt)
        - [Data Binding Artboards](https://github.com/rive-app/rive-android/blob/master/app/src/main/java/app/rive/runtime/example/ComposeArtboardBindingActivity.kt)
        - [Data Binding Lists](https://github.com/rive-app/rive-android/blob/master/app/src/main/java/app/rive/runtime/example/ComposeListActivity.kt)
      </Tab>
      <Tab title="Legacy">
        See the [data binding overview example](https://github.com/rive-app/rive-android/blob/master/app/src/main/java/app/rive/runtime/example/LegacyDataBindingActivity.kt).
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="Flutter">
    - [Data binding overview](https://github.com/rive-app/rive-flutter/blob/master/example/lib/examples/databinding.dart)
    - [Data binding images](https://github.com/rive-app/rive-flutter/blob/master/example/lib/examples/databinding_images.dart)
    - [Data binding artboards](https://github.com/rive-app/rive-flutter/blob/master/example/lib/examples/databinding_artboards.dart)
    - [Data binding lists](https://github.com/rive-app/rive-flutter/blob/master/example/lib/examples/databinding_lists.dart)
  </Tab>

  <Tab title="React Native">
    <Tabs>
      <Tab title="New Runtime (Recommended)">
        See the [example app](https://github.com/rive-app/rive-nitro-react-native/tree/main/example) for data binding demos with the new runtime.
      </Tab>
      <Tab title="Legacy Runtime">
        See the [Data Binding view](https://github.com/rive-app/rive-react-native/blob/main/example/app/\(examples\)/DataBinding.tsx) in the Example app for a demo.
      </Tab>
    </Tabs>
  </Tab>

</Tabs>
