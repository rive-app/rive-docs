---
title: "Data Binding Overview"
description: "Unreal Data Binding Fundamentals"
---

<Note>
  If you're unfamiliar with Rive's databinding, please see [Data Binding](runtimes/data-binding) to get an understanding of the fundamental concepts.
</Note>

## üîß Data Binding Overview

The Rive Unreal Plugin integrates the Rive ViewModel architecture into Unreal Engine, enabling dynamic data-driven content and interaction. Through **data binding**, you can expose gameplay variables, user input, or UI state directly to your Rive animations using a declarative model.

### üî© Core Components

- `URiveViewModel`: A UObject wrapper around a `rive::ViewModelRuntime`. Represents a Rive-defined schema with properties and instance templates.
- `URiveViewModelInstance`: Holds runtime values for a ViewModel. Wraps `rive::ViewModelInstanceRuntime` and provides typed property accessors.
- `URiveViewModelInstanceValue`: Base class for all runtime properties. Derived types include:
  - `URiveViewModelInstanceBoolean`
  - `URiveViewModelInstanceNumber`
  - `URiveViewModelInstanceString`
  - `URiveViewModelInstanceColor`
  - `URiveViewModelInstanceEnum`
  - `URiveViewModelInstanceTrigger`
  - Nested ViewModels: `URiveViewModelInstance`
- **Binding Targets**: Instances can be bound to:
  - `URiveArtboard` ‚Äì sets the data context for a Rive artboard.
  - `FRiveStateMachine` ‚Äì synchronizes ViewModel data with state machine inputs and outputs. Currently, binding to a `URiveArtboard` automatically bind to the state machine.

### üîÑ Lifecycle

1. **Load ViewModel** via `URiveFile`:

   ```cpp
   URiveViewModel* ViewModel = RiveFile->GetViewModelByName("MyData"); 
   ```
2. **Create Instance**:

   ```cpp
   URiveViewModelInstance* Instance = ViewModel->CreateInstance(); 
   ```
3. **Bind to Artboard**:

   ```
   Artboard->SetViewModelInstance(Instance);
   ```
4. **Interact with Properties** (e.g. trigger a state or update text):

   ```cpp
   Instance->SetStringPropertyValue("Username", "RiveUser"); Instance->FireTriggerProperty("Login"); 
   ```
5. **Respond to Changes**:

   ```cpp
   NameProperty->BindToValueChange(MyCallback); 
   ```

### ‚öôÔ∏è Architecture Highlights

- Property wrappers expose **typed getters/setters** in both C\+\+ and Blueprint.
- Delegates support **multi-cast change detection**.
- ViewModelInstances can contain **nested ViewModels and lists**.
- Callbacks are **tracked and invoked safely** via `HandleCallbacks()` (called per-frame by `URiveArtboard::AdvanceStateMachine()`).