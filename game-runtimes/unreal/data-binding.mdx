---
title: "Data Binding "
description: "Unreal Data Binding Fundamentals"
---

<Note>
  If you're unfamiliar with Rive's databinding, please see [Data Binding](runtimes/data-binding) to get an understanding of the fundamental concepts.
</Note>

The **Data Binding** system integrates Rive's ViewModel architecture directly into Unreal Engine, enabling dynamic and declarative connections between Rive artboard properties and Unreal gameplay logic or UI systems.

### 🔧 Core Concepts

- **ViewModel** (`URiveViewModel`): Represents a Rive data model with one or more named instances that can be dynamically created and bound to an artboard. Each ViewModel exposes a set of typed properties.
- **ViewModelInstance** (`URiveViewModelInstance`): A live runtime object that holds property values for a specific ViewModel. It supports nested ViewModels and instance lists.
- **Bindable Properties**: Properties inside a ViewModel can be one of several types:
  - `Boolean`, `Number`, `String`, `Color`, `Enum`, `Trigger`, or another nested `ViewModelInstance`.
- **Callbacks**: Unreal delegates (`OnValueChanged`) are used to detect changes and propagate updates via Blueprint or C\+\+ code. These callbacks are broadcast when Rive property changes are detected via polling.

### 🔁 Lifecycle

1. **Initialization**:
   - `URiveViewModel` wraps a `rive::ViewModelRuntime*`, created via `File::viewModelByName` or `viewModelByIndex`.
   - You can create a default or named `URiveViewModelInstance` from the ViewModel.
2. **Binding to Artboard**:
   - The instance is attached to an `URiveArtboard` using `SetViewModelInstance`, which binds the instance to both the Artboard and any associated `StateMachine`.
3. **Property Access & Mutation**:
   - Property values can be retrieved and updated by name via typed getters/setters, e.g.:

     ```cpp
     ViewModelInstance->SetNumberPropertyValue("Health", 100.0f);
     FString Name = ViewModelInstance->GetStringPropertyValue("Username");
     ```
   - Triggers can be fired:

     ```cpp
     ViewModelInstance->FireTriggerProperty("OnStart");
     ```
4. **Change Detection**:
   - Changes to properties are tracked internally. If a property value has changed, the plugin clears the change flag and broadcasts a multicast delegate.
5. **Blueprint Integration**:
   - All ViewModelInstance properties expose Blueprint-callable methods and event hooks for runtime or UI-driven interactivity.

### 🧩 Features

- **Nested Instances**: ViewModels can reference other ViewModels as properties, allowing deeply nested data structures.
- **Dynamic Callback Management**: Automatically handles registration and unregistration of properties as callback targets for efficient polling.
- **Robust Logging and Error Handling**: Warns on missing properties or type mismatches to ease debugging and integration.