---
title: Observing ViewModel Changes
description: React to animation and state updates by observing ViewModel property changes.
---

# Observing ViewModel Changes

In the Unreal runtime, **ViewModels** are the supported way for Rive content to communicate back to Unreal.

Legacy **State Machine** events and direct callback mechanisms are deprecated.  
New integrations should observe **ViewModel** property changes instead.

<Info>
All runtime output from Rive should flow through a **ViewModel Instance**.
</Info>

## How Observation Works

During the **Artboard** tick:

1. Unreal sets **ViewModel** values
2. The **State Machine** evaluates transitions
3. The **State Machine** may modify **ViewModel** values
4. Property change callbacks are emitted
5. Rendering occurs

Observation happens synchronously during this update cycle.

<Warning>
If the **Artboard** is not ticked, property change callbacks will not fire.
</Warning>

## Registering Callbacks

Each property on a **ViewModel Instance** can be observed.

When a property changes:

- The callback is invoked
- The updated value is available
- Logic can react immediately

Callbacks should be:

- Registered after creating the **ViewModel Instance**
- Unregistered before destroying the instance
- Owned by the same system that owns the instance

## Observing Trigger Properties

A **Trigger Property** can be used as a one-shot signal.

Common use cases:

- Button click notifications
- Animation milestones
- State transition signals
- Gameplay triggers

When fired:

- The trigger activates during the next tick
- The property resets automatically
- The observer receives the callback

<Tip>
Use **Trigger Properties** for actions.  
Use boolean or numeric properties for persistent state.
</Tip>

## Observing Structured Data

Because **ViewModels** may contain nested structures:

- Nested **ViewModel Instances** can also be observed
- Changes propagate through the same callback mechanism
- Observation remains consistent regardless of hierarchy depth

This allows complex UI or gameplay state to remain structured and predictable.

## Blueprint vs C++ Observation

Observation works in both environments.

Blueprint is appropriate for:

- UI updates
- Designer-authored reactions
- Prototyping

C++ is recommended for:

- Coordinating multiple systems
- Performance-sensitive logic
- Centralized event routing

Keep per-frame logic in C++, and keep Blueprint reactive.

## Lifetime and Safety

Observation follows the lifetime of the **ViewModel Instance**.

Important rules:

- Do not observe destroyed instances
- Unbind callbacks before destroying instances
- Do not assume callbacks persist after **Artboard** reinitialization

Callbacks are synchronous and not asynchronous events.

## Replacing Deprecated Events

If upgrading from legacy event APIs:

Old pattern:
- Listen for **State Machine** events

New pattern:
- Use a **Trigger Property**
- Observe that property on the **ViewModel Instance**

This keeps animation logic and engine logic cleanly separated.

<Warning>
Do not mix legacy event callbacks with **ViewModel** observation in new integrations.
</Warning>

## Common Mistakes

- Observing a **ViewModel Instance** that is not bound
- Expecting callbacks without ticking the **Artboard**
- Using triggers for persistent state
- Performing heavy logic inside callbacks

## Summary

**ViewModels** are both the input and output boundary of the runtime.

Unreal writes values.  
The **State Machine** evaluates.  
Unreal observes changes.

## Next Steps

- Decide when to use **Blueprint vs C++**
- Understand **Loading Assets**
- Review **Threading & Safety**
- Read the **Migration Guide** if upgrading
