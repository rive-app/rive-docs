---
title: Loading Assets
description: Understand how Rive assets are imported, resolved, and managed at runtime in Unreal.
---

# Loading Assets

A **Rive File** may reference external assets such as images and fonts.  
The Unreal runtime resolves these assets during file initialization and manages them for the lifetime of the file.

<Info>
Assets are resolved at the **Rive File** level, not per **Artboard**.
</Info>

## What Is Considered an Asset?

A **Rive File** may contain references to:

- Image assets
- Font assets
- Embedded resources
- Audio references (if authored)

These are defined inside the `.riv` file and resolved by the Unreal runtime.

## Import-Time Behavior

When a `.riv` file is imported into Unreal:

- A **Rive File** asset is created
- Embedded metadata is parsed
- Asset references are discovered
- Unreal-side wrappers are prepared

This prepares the file for runtime initialization.

<Info>
Importing a `.riv` file does not create an **Artboard**.  
Runtime objects are created separately.
</Info>

## Runtime Initialization

When a **Rive File** is initialized:

- The runtime resolves referenced assets
- Renderer resources are prepared
- Assets are cached internally
- The file becomes ready for **Artboard** creation

If an asset cannot be resolved:

- The file may still initialize
- Some visual elements may be missing
- Errors will be logged

<Warning>
Do not create or use an **Artboard** before the **Rive File** has completed initialization.
</Warning>

## Asset Ownership

Assets are owned by the **Rive File**.

This means:

- Multiple **Artboards** share the same assets
- Assets are not duplicated per **Artboard**
- Memory usage scales with file count, not instance count

Destroying a **Rive File** releases its associated assets.

Destroying an **Artboard** does not unload assets.

## Fonts and Text

Text objects may reference fonts embedded or linked in the **Rive File**.

Font handling:

- Occurs during file initialization
- Is shared across all **Artboards**
- Does not support runtime swapping without reinitialization

If a font fails to load, fallback rendering may occur.

## Image Assets

Image assets referenced in the file:

- Are resolved during initialization
- Are uploaded to the renderer as needed
- Are shared across **Artboards**

Missing images may result in incomplete rendering.

## Audio Assets

If audio is referenced in the file:

- It is resolved during file initialization
- Playback behavior depends on runtime support
- Triggering should occur via **ViewModel** logic

Audio support may vary by platform.

## Asynchronous Considerations

Asset loading may involve background work.

Initialization may:

- Synchronize with the render thread
- Block until resources are ready
- Complete asynchronously before use

<Warning>
Treat file initialization as a readiness boundary.  
Do not assume assets are available immediately after object creation.
</Warning>

## Reinitialization

If a **Rive File** is reimported or reloaded:

- Existing **Artboards** may become invalid
- Assets may be reloaded
- **ViewModel** bindings may need to be reapplied

Handle reinitialization deliberately and avoid assuming persistence.

## Common Mistakes

- Creating **Artboards** before initialization completes
- Assuming assets are loaded per **Artboard**
- Destroying a **Rive File** while **Artboards** still exist
- Expecting runtime asset swapping without reinitialization

## Summary

Asset loading is:

- File-scoped
- Explicit
- Shared across **Artboards**
- Managed by the runtime

Understanding asset ownership prevents memory leaks and invalid references.

## Next Steps

- Review **Threading & Safety**
- Read the **Migration Guide** if upgrading from legacy APIs
