---
title: State Machines
description: Understand how State Machines evaluate logic inside an Artboard.
---

# State Machines

A **State Machine** defines how animation logic evaluates inside an **Artboard**.

In the Unreal runtime, **State Machines** consume and modify **ViewModel** properties.  

<Info>
Legacy direct input APIs and legacy event callbacks are deprecated.  
New integrations should use **ViewModels** as the data boundary.
</Info>

## What Is a State Machine?

A **State Machine** is authored in the Rive Editor and embedded in a **Rive File**.

At runtime:

- A **State Machine** runs inside an **Artboard**
- It reads **ViewModel** properties
- It updates animation state
- It may modify **ViewModel** properties
- It may fire **Trigger Properties**

Only one **State Machine** is active per **Artboard** at a time.

## Selecting a State Machine

If a **Rive File** contains multiple **State Machines**, you must select which one to run when creating or initializing the **Artboard**.

Switching **State Machines**:

- Resets internal animation state
- Does not persist previous transitions
- May require rebinding **ViewModels**

<Warning>
Switching a **State Machine** resets its internal state. Do not assume continuity across switches.
</Warning>

## How State Machines Receive Data

**State Machines** consume values from a bound **ViewModel**.

Typical flow:

1. Unreal sets a **ViewModel** property
2. The **Artboard** is advanced
3. The **State Machine** evaluates transitions
4. Animation state updates

This keeps animation logic decoupled from engine code.

## Trigger Properties

A **Trigger Property** is a one-shot signal defined in a **ViewModel**.

When fired:

- The **State Machine** evaluates matching transitions
- The trigger automatically resets
- Changes take effect during the next tick

<Tip>
Use **Trigger Properties** for actions.  
Use boolean and number properties for state.
</Tip>

## State Machine Evaluation Timing

Evaluation occurs during the **Artboard** tick.

The update order is:

1. Unreal modifies **ViewModel** values
2. The **Artboard** advances
3. The **State Machine** evaluates transitions
4. **ViewModel** outputs may change
5. Rendering occurs

<Warning>
If the **Artboard** is not ticked, the **State Machine** does not run.
</Warning>

## Multiple State Machines

If a **Rive File** contains multiple **State Machines**:

- Only one may run per **Artboard**
- Each **Artboard** instance is independent
- Multiple **Artboards** can run different **State Machines** simultaneously

## What State Machines Do Not Do

**State Machines** do not:

- Tick automatically
- Render automatically
- Persist state after reinitialization
- Communicate directly with Unreal

All communication occurs through **ViewModels**.

## Common Mistakes

- Forgetting to bind a **ViewModel**
- Switching **State Machines** without reinitializing data
- Failing to tick the **Artboard**

## Relationship to Other Systems

- **Artboards** own and evaluate **State Machines**
- **ViewModels** provide both input and output
- Property change callbacks expose results back to Unreal

## Next Steps

- Bind structured data using **ViewModels & Data Binding**
- Observe runtime changes via **ViewModel Callbacks**
