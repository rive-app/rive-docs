---
title: "World-Space RenderTargets"
description: "Drag a Rive RenderTarget into the level to create an in-world surface with an auto-generated material."
---

# World-Space RenderTargets

The fastest way to put Rive content on a mesh in world space is to use a **Rive RenderTarget** asset.

You can drag a **Rive RenderTarget** directly into the level. Unreal will:

- Spawn an actor in the scene
- Create a material that displays the RenderTarget texture
- Assign the material to the spawned mesh

This workflow is ideal for:

- In-world screens
- Monitors / kiosks
- Control panels
- “TV” surfaces

<Info>
  This page covers world-space RenderTargets.\
  For screen-space UI (HUDs/menus), use **URiveWidget**.
</Info>

## 1) Create a Rive RenderTarget asset

1. In the Content Browser, click **Add (+)**.
2. Search for **Rive RenderTarget** (or **Rive Render Target 2D**).
3. Create the asset (e.g. `RT_RiveScreen`).

Configure the RenderTarget asset:

- **Rive File**
- **Artboard**
- **State Machine** (optional)
- **Size / Resolution**

<Tip>
  Start with 512×512. Increase only if the screen is large and close to the camera.
</Tip>

## 2) Drag it into the Level

Drag `RT_RiveScreen` from the Content Browser into the viewport.

Unreal will automatically create:

- A scene actor that displays the RenderTarget
- A material that samples the RenderTarget texture
- A mesh with that material applied

At this point you should see the Rive content on the surface.

## 3) How updates work (Tick + Draw)

A RenderTarget is a texture output. It only changes when the runtime is advanced and drawn.

In practice, you must ensure there is a driver in your scene that:

- Advances the runtime (Tick)
- Draws the frame into the RenderTarget (Draw)

<Warning>
  If nothing is driving the RenderTarget, it will appear static.
</Warning>

The recommended driver for RenderTargets is **URiveActorComponent**, which is designed specifically for in-world textures.

## 4) Driving the RenderTarget with URiveActorComponent

If you are using the RenderTarget workflow, place an Actor in the level that owns the runtime and renders to the target.

Typical setup:

1. Create an Actor Blueprint (e.g. `BP_RiveRenderDriver`)
2. Add **URiveActorComponent**
3. Point it at the same Rive file/artboard/state machine settings
4. Set the RenderTarget size to match your in-world screen needs

<Info>
  **URiveActorComponent** is intended for RenderTargets (world-space textures).\
  It is not intended for screen-space widgets.
</Info>

## 5) Updating configuration

To change what the world-space screen displays:

- Update the **Rive RenderTarget** asset configuration (file/artboard/state machine)
- Or update the runtime driver’s configuration (descriptor/view model)

If your Rive content is interactive (state machine + view model):

- Bind a ViewModel
- Set ViewModel values
- Fire triggers

The RenderTarget will reflect changes the next time it is driven (tick/draw).

## Common Mistakes

- Dragging a RenderTarget into the level but not having any runtime driver active
- Using a very large RenderTarget resolution by default (e.g. 2048×2048)
- Expecting the RenderTarget to update without a tick/draw driver
- Using **URiveActorComponent** for widgets (it’s for world-space textures)