---
title: Artboards & Rendering
description: Understand how Artboards are evaluated and rendered, and how URiveActorComponent drives the runtime.
---

# Artboards & Rendering

An **Artboard** is the core runtime object responsible for evaluating animation and producing render output.

Understanding how **Artboards** work is essential before working with **State Machines** or **ViewModels**.

<Info>
A **Rive File** is an Unreal asset. An **Artboard** is a runtime instance created from that asset.
</Info>

## Rive File vs Artboard

A **Rive File**:

- Is an Unreal asset
- Contains one or more **Artboards**
- May contain **State Machines**
- May define **ViewModels**
- Does not render directly

An **Artboard**:

- Is created at runtime
- Owns animation state
- Evaluates **State Machines**
- Consumes and modifies **ViewModels**
- Produces render data
- Does not tick or render on its own

## How Ticking and Rendering Work in Unreal

While an **Artboard** must be advanced and rendered explicitly, most projects should not do this manually.

The recommended runtime driver is:

### **URiveActorComponent**

**URiveActorComponent**:

- Owns a `URiveRenderTarget2D`
- Initializes on `BeginPlay`
- Ticks every frame (`TickComponent`)
- Calls `Draw()` internally
- Exposes `GetTexture()` for UI display

<Info>
In most projects, you do not manually tick an **Artboard**.  
The component handles ticking and rendering for you.
</Info>

## Artboard Lifecycle

Internally, the lifecycle still follows:

1. Load a **Rive File**
2. Create an **Artboard**
3. Optionally bind a **ViewModel**
4. Advance the **Artboard**
5. Render the **Artboard**
6. Destroy when no longer needed

When using **URiveActorComponent**, this lifecycle is managed automatically.

<Warning>
If you bypass the component and manage **Artboards** directly, you are responsible for ticking and rendering explicitly.
</Warning>

## Selecting an Artboard

A single **Rive File** may contain multiple **Artboards**.

When configuring **URiveActorComponent**, you select:

- **RiveFile**
- **ArtboardName**
- **StateMachineName** (optional)

Each component instance runs its own **Artboard**.

Multiple components can reference the same **Rive File**.

## Rendering Model

Rendering is performed into an internal **URiveRenderTarget2D**.

The output texture is accessible via:

UTexture* URiveActorComponent::GetTexture()


This texture can be:

- Displayed in UMG
- Applied to a material
- Used in a 3D mesh
- Fed into post-processing

Ticking and rendering are coordinated internally with Unrealâ€™s render thread.

---

## Display in UMG (Component Path)

The correct UMG workflow is:

1. Add **URiveActorComponent** to an Actor
2. Let it tick automatically
3. Use `GetTexture()` to display the output in a UMG Image

<Tabs>
  <Tab title="Blueprint">
    1. Create an Actor Blueprint (e.g. `BP_RiveHost`)
    2. Add the **Rive** component
    3. Set:
       - **DefaultRiveDescriptor**
       - **Size**
    4. In your Widget Blueprint:
       - Get reference to `BP_RiveHost`
       - Get its Rive component
       - Call `GetTexture()`
       - Assign to an Image brush
  </Tab>

  <Tab title="C++">
    ```cpp
    // Get texture from component
    UTexture* Tex = RiveComponent->GetTexture();

    if (Tex)
    {
        FSlateBrush Brush;
        Brush.SetResourceObject(Tex);
        ImageWidget->SetBrush(Brush);
    }
    ```
  </Tab>
</Tabs>

<Info>
UMG does not tick Rive.  
The Actor Component is responsible for ticking and drawing.
</Info>

## Size and Resolution

The component exposes a `Size` property that controls the render target resolution.

Changing resolution:

- Affects output texture size
- Does not change intrinsic **Artboard** layout
- Can be updated via `ResizeRenderTarget()`

## Multiple Artboards

Multiple **URiveActorComponent** instances:

- Can reference the same **Rive File**
- Maintain independent animation state
- Maintain independent **ViewModel** bindings
- Render independently

Memory usage scales primarily with file count, not instance count.

## Common Mistakes

- Adding a Rive file but never adding **URiveActorComponent**
- Trying to tick an **Artboard** manually while also using the component
- Destroying the owning Actor while still referencing the texture
- Polling every frame in UMG instead of letting the component drive updates

## Relationship to Other Concepts

- **State Machines** run inside an **Artboard**
- **ViewModels** are bound to an **Artboard**
- **URiveActorComponent** owns and advances the runtime
- Property change callbacks are emitted during **Artboard** tick

Everything flows through the **Artboard**, but most projects interact through the component.

## Next Steps

- Learn how **State Machines** evaluate logic
- Bind data using **ViewModels & Data Binding**
- Observe runtime changes via **ViewModel Callbacks**
