---
title: Artboards & Rendering
description: Understand how Artboards are created, ticked, and rendered in Unreal.
---

# Artboards & Rendering

An **Artboard** is the core runtime object responsible for evaluating animation and producing render output.

Understanding how **Artboards** work is essential before working with **State Machines** or **ViewModels**.

<Info>
A **Rive File** is an Unreal asset. An **Artboard** is a runtime instance created from that asset.
</Info>

## Rive File vs Artboard

A **Rive File**:

- Is an Unreal asset
- Contains one or more **Artboards**
- May contain **State Machines**
- May define **ViewModels**
- Does not render directly

An **Artboard**:

- Is created at runtime
- Owns animation state
- Evaluates **State Machines**
- Consumes and modifies **ViewModels**
- Must be ticked explicitly
- Must be rendered explicitly

## Artboard Lifecycle

The typical lifecycle is:

1. Load a **Rive File**
2. Create an **Artboard**
3. Optionally bind a **ViewModel**
4. Advance the **Artboard** each frame
5. Render the **Artboard**
6. Destroy the **Artboard** when no longer needed

<Warning>
An **Artboard** does not tick or render automatically.
</Warning>

## Selecting an Artboard

A single **Rive File** may contain multiple **Artboards**.

When creating an **Artboard**, you must select:

- An artboard by name  
- Or an artboard by index  

Each created **Artboard** instance is independent and maintains its own animation state.

Multiple **Artboards** can be created from the same **Rive File**.

## Ticking an Artboard

Ticking advances the internal animation and logic.

Advancing an **Artboard**:

- Evaluates animation timelines
- Updates **State Machines**
- Applies **ViewModel** changes
- Emits property change callbacks
- Prepares render data

Ticking should occur once per frame from the game thread.

<Tip>
Centralize **Artboard** ticking in C++ and keep Blueprint reactive.
</Tip>

## Rendering an Artboard

Rendering is explicit.

Rendering typically involves:

- Applying layout and transforms
- Drawing into a render target or widget
- Submitting draw commands through the runtime

The runtime coordinates with Unrealâ€™s render thread internally.

<Info>
Rendering does not automatically occur when ticking.  
Ticking and rendering are separate responsibilities.
</Info>

## Size and Layout

Each **Artboard** has an intrinsic size defined in the Rive file.

You can:

- Query the original size
- Set a custom render size
- Apply transforms
- Align content within bounds

Layout adjustments affect rendering only and do not modify source data.

## Multiple Artboards

Multiple **Artboards** created from the same **Rive File**:

- Share loaded assets
- Maintain independent animation state
- Maintain independent **ViewModel** bindings
- Can render simultaneously

Memory usage scales with file count, not **Artboard** count.

## Common Mistakes

- Creating an **Artboard** but never ticking it
- Rendering without advancing the **Artboard**
- Destroying a **Rive File** before its **Artboards**
- Assuming state persists after reinitialization

## Relationship to Other Concepts

- **State Machines** run inside an **Artboard**
- **ViewModels** are bound to an **Artboard**
- Property change callbacks are emitted during **Artboard** tick

Everything in the runtime flows through the **Artboard**.

## Next Steps

- Learn how **State Machines** evaluate logic
- Bind data using **ViewModels & Data Binding**
- Observe runtime changes via **ViewModel Callbacks**
- Review **Threading & Safety**
