---
title: Artboards & Rendering
description: Understand how Artboards are created, ticked, and rendered in Unreal.
---

# Artboards & Rendering

An **Artboard** is the core runtime object responsible for evaluating animation and producing render output.

Understanding how **Artboards** work is essential before working with **State Machines** or **ViewModels**.

<Info>
A **Rive File** is an Unreal asset. An **Artboard** is a runtime instance created from that asset.
</Info>

## Rive File vs Artboard

A **Rive File**:

- Is an Unreal asset
- Contains one or more **Artboards**
- May contain **State Machines**
- May define **ViewModels**
- Does not render directly

An **Artboard**:

- Is created at runtime
- Owns animation state
- Evaluates **State Machines**
- Consumes and modifies **ViewModels**
- Must be ticked explicitly
- Must be rendered explicitly

## Artboard Lifecycle

The typical lifecycle is:

1. Load a **Rive File**
2. Create an **Artboard**
3. Optionally bind a **ViewModel**
4. Advance the **Artboard** each frame
5. Render the **Artboard**
6. Destroy the **Artboard** when no longer needed

<Warning>
An **Artboard** does not tick or render automatically.
</Warning>

## Selecting an Artboard

A single **Rive File** may contain multiple **Artboards**.

When creating an **Artboard**, you must select:

- An artboard by name  
- Or an artboard by index  

Each created **Artboard** instance is independent and maintains its own animation state.

Multiple **Artboards** can be created from the same **Rive File**.

## Ticking an Artboard

Ticking advances the internal animation and logic.

Advancing an **Artboard**:

- Evaluates animation timelines
- Updates **State Machines**
- Applies **ViewModel** changes
- Emits property change callbacks
- Prepares render data

Ticking should occur once per frame from the game thread.

<Tip>
Centralize **Artboard** ticking in C++ and keep Blueprint reactive.
</Tip>

## Rendering an Artboard

Rendering is explicit.

Rendering typically involves:

- Applying layout and transforms
- Drawing into a render target or widget
- Submitting draw commands through the runtime

The runtime coordinates with Unreal’s render thread internally.

<Info>
Rendering does not automatically occur when ticking.  
Ticking and rendering are separate responsibilities.
</Info>

## Size and Layout

Each **Artboard** has an intrinsic size defined in the Rive file.

You can:

- Query the original size
- Set a custom render size
- Apply transforms
- Align content within bounds

Layout adjustments affect rendering only and do not modify source data.

## Multiple Artboards

Multiple **Artboards** created from the same **Rive File**:

- Share loaded assets
- Maintain independent animation state
- Maintain independent **ViewModel** bindings
- Can render simultaneously

Memory usage scales with file count, not **Artboard** count.

# Display in UMG

This is the fastest way to get a **Rive** **Artboard** on screen: render it inside a UMG widget.

<Info>
UMG is Unreal’s standard UI system. If you’re new to UMG, Epic’s docs are the best starting point. :contentReference[oaicite:0]{index=0}
</Info>

## Blueprint: Create a Rive Widget

Use the built-in Blueprint node **Create Rive Widget** to spawn a widget configured for a `.riv` asset.

<Tabs>
  <Tab title="Blueprint">
    1. Create a **Widget Blueprint** (for example: `WBP_MainHUD`).
    2. In the Designer, add a container (Canvas / Overlay / SizeBox) where you want the Rive to render.
    3. In the Graph (Event Construct or when you initialize your UI):
       - Call **Create Rive Widget**
       - Add it to your layout (for example, add to an Overlay/Canvas slot)
    4. Set the widget’s Rive configuration (Rive file / artboard / state machine / view model) using the widget’s exposed properties or the helper functions provided by the plugin.

    <Tip>
    The plugin release notes explicitly call out fixes and defaults around **Create Rive Widget**, so it’s the intended entry-point for UMG. :contentReference[oaicite:1]{index=1}
    </Tip>
  </Tab>

  <Tab title="C++ (UMG host)">
    Use C++ to *host* the UI (create and add the Widget Blueprint to the viewport), while letting the Widget Blueprint itself create/configure the Rive widget.

    ```cpp
    // MyHUD.cpp
    #include "MyHUD.h"
    #include "Blueprint/UserWidget.h"

    void AMyHUD::BeginPlay()
    {
        Super::BeginPlay();

        if (!MainHudWidgetClass) return;

        UUserWidget* Hud = CreateWidget<UUserWidget>(GetWorld(), MainHudWidgetClass);
        if (!Hud) return;

        Hud->AddToViewport();
    }
    ```

    ```cpp
    // MyHUD.h
    #pragma once

    #include "CoreMinimal.h"
    #include "GameFramework/HUD.h"
    #include "MyHUD.generated.h"

    UCLASS()
    class AMyHUD : public AHUD
    {
        GENERATED_BODY()

    protected:
        virtual void BeginPlay() override;

    public:
        UPROPERTY(EditDefaultsOnly, Category="UI")
        TSubclassOf<UUserWidget> MainHudWidgetClass;
    };
    ```

    <Tip>
    This pattern keeps Rive configuration and layout in UMG (Blueprint), while keeping creation/ownership in C++ — a common Unreal workflow for UI.
    </Tip>
  </Tab>
</Tabs>

## Common Mistakes

- Creating an **Artboard** but never ticking it
- Rendering without advancing the **Artboard**
- Destroying a **Rive File** before its **Artboards**
- Assuming state persists after reinitialization

## Relationship to Other Concepts

- **State Machines** run inside an **Artboard**
- **ViewModels** are bound to an **Artboard**
- Property change callbacks are emitted during **Artboard** tick

Everything in the runtime flows through the **Artboard**.

## Next Steps

- Learn how **State Machines** evaluate logic
- Bind data using **ViewModels & Data Binding**
- Observe runtime changes via **ViewModel Callbacks**
- Review **Threading & Safety**
