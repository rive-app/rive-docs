---
title: ViewModels & Data Binding
description: Use ViewModels as the structured data boundary between Unreal and Rive.
---

# ViewModels & Data Binding

A **ViewModel** defines a structured, typed data interface between Unreal and Rive.

In the Unreal runtime, **ViewModels** are the primary way to:

- Send data into a **State Machine**
- Receive data back from animation logic

<Info>
All new integrations should use **ViewModels** as the data boundary.
</Info>

## What Is a ViewModel?

A **ViewModel** is authored in the Rive Editor and embedded in a **Rive File**.

It defines:

- Property names
- Property types
- Optional nested structures

At runtime, you create a **ViewModel Instance**, which holds actual values.

## ViewModel vs ViewModel Instance

It is important to distinguish:

- **ViewModel** — the definition in the file  
- **ViewModel Instance** — the runtime object containing values  

Multiple **ViewModel Instances** can be created from the same **ViewModel** definition.

Each instance:

- Stores independent values
- Can be bound to a different **Artboard**
- Can be destroyed without affecting other instances

## Binding a ViewModel

An **Artboard** may have one active **ViewModel Instance** bound at a time.

When bound:

- The **State Machine** reads property values
- The **State Machine** may modify property values
- **Trigger Properties** can drive transitions
- Property changes become observable in Unreal

<Warning>
Modifying a **ViewModel Instance** that is not bound to an **Artboard** has no effect on animation.
</Warning>

## Supported Property Types

**ViewModels** support strongly typed properties:

- Boolean
- Number
- String
- Enum
- Color
- **Trigger Property**

Each property type has appropriate runtime accessors.

## Setting ViewModel Values

Unreal drives animation logic by setting **ViewModel** property values.

Typical examples:

- Updating UI state
- Changing animation mode
- Driving progress indicators
- Firing **Trigger Properties**

Changes take effect during the next **Artboard** tick.

<Tip>
Set properties first, then advance the **Artboard**.
</Tip>

## Trigger Properties

A **Trigger Property** is a one-shot signal.

When fired:

- The **State Machine** evaluates transitions
- The trigger resets automatically
- The effect applies during the next tick

Triggers are preferred over legacy event-style APIs.

## Nested ViewModels

**ViewModels** may contain nested **ViewModels**.

This allows:

- Structured data hierarchies
- Reusable data definitions
- Complex UI state modeling

Nested instances are created automatically when instantiating a parent **ViewModel Instance**.

## Data Flow Model

The full runtime data flow is:

Unreal → **ViewModel Instance** → **State Machine** → **ViewModel Instance** → Unreal

Unreal writes values.
The **State Machine** reacts.
Updated values can be observed.

## Lifetime and Ownership

**ViewModel Instances** are runtime objects.

Important rules:

- They must outlive the **Artboard** using them
- They must be destroyed explicitly when no longer needed
- Destroying an instance invalidates its callbacks

Keep ownership clear and hierarchical.

<Warning>
Do not mutate **ViewModel Instances** from background threads.
</Warning>

## Common Mistakes

- Creating a **ViewModel Instance** but never binding it
- Treating **Trigger Properties** as persistent state
- Destroying a **ViewModel Instance** while still bound
- Expecting immediate animation updates without ticking

## Relationship to Other Systems

- **Artboards** evaluate **State Machines**
- **State Machines** read and write **ViewModel** properties
- Property change callbacks expose results back to Unreal

## Next Steps

- Learn how to **Observe ViewModel Changes**
