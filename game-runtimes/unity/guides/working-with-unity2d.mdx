---
description: "Description of your new file."
title: "Using Rive with Unity 2D"
---

Rive renders to a RenderTexture in Unity, making it compatible with Unity features that support RenderTextures. This approach provides flexibility but requires specific considerations when working with Unity's 2D rendering pipeline.

## Working with SpriteRenderers

While Rive works well with Unity overall, **SpriteRenderers** don't natively handle RenderTextures optimally. There are two main approaches to address this:

1. **Using RiveTextureRenderer with Quads (Recommended)**

   * Render Rive animations to a Quad using the RiveTextureRenderer component

   * Does not require a shader workaround

   * Works the same in 2D and 3D

2. **Custom Shader Solution for SpriteRenderers**

   * Useful when you need to maintain precise sorting order with other sprites

   * Allows Rive content to work within the existing sprite rendering pipeline

   * Requires a custom shader implementation

If you need to maintain sort order when mixing Rive content with SpriteRenderers, you can use the following custom shader:

```
Shader "Custom/SpriteTextureOverride"
{
    Properties
    {
        // SpriteRenderer will automatically assign a texture here at runtime
        // We declare it but won't use it
        _MainTex ("Default Sprite", 2D) = "white" {}
        
        // This is our actual texture that we want to display
        // Could be a RenderTexture or any other texture
        _OverrideTexture ("Override Texture", 2D) = "white" {}
    }
    
    SubShader
    {
        // Standard sprite rendering tags
        Tags { "RenderType"="Opaque" }
        LOD 100
        
        Pass
        {
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #include "UnityCG.cginc"
            
            struct appdata
            {
                float4 vertex : POSITION;
                float2 uv : TEXCOORD0;
            };
            
            struct v2f
            {
                float2 uv : TEXCOORD0;
                float4 vertex : SV_POSITION;
            }; 
            
            sampler2D _MainTex;
            float4 _MainTex_ST;
            sampler2D _OverrideTexture;
            float4 _OverrideTexture_ST;
            
            v2f vert (appdata v)
            {
                v2f o;
                o.vertex = UnityObjectToClipPos(v.vertex);
                o.uv = TRANSFORM_TEX(v.uv, _MainTex);
                return o;
            }
            
            fixed4 frag (v2f i) : SV_Target
            {
                fixed4 color = tex2D(_OverrideTexture, i.uv);
                return color;
            }
            ENDCG
        }
    }
}
```



To implement this solution:

1. Create a new shader file in your project and paste the above code

2. Create a new material using this shader

3. Assign the material to your SpriteRenderer

4. Use RiveTextureRenderer to set the OverrideTexture property with your Rive RenderTexture

<Warning>
  When using the custom shader approach with SpriteRenderers, pointer input is not automatically supported. This is because SpriteRenderers and SpriteColliders do not provide `textureCoords` like Quads and MeshColliders do.&#x20;



  If you need pointer input support, consider using the recommended Quad approach with RiveTextureRenderer instead.
</Warning>