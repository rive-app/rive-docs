---
title: "Script Inputs"
sidebarTitle: "Script Inputs"
description: ""
---

Scripted Inputs are the bridge between your scripts and the Rive editor, allowing you to customize and control script behavior through custom input fields.

By defining inputs in your scripts, you expose configurable properties — like numbers, colors, booleans, and artboard components — that appear directly in the Rive interface. This means you can write the logic once in a script, and then experiment freely with values, animate properties over time, bind data from external sources, and reuse the same script across multiple instances with different configurations. Inputs transform static scripts into flexible, designer-friendly tools that enable true collaboration and rapid iteration.

Scripted Inputs
- let you pass data into your script
- can be view models, allowing you to control anything
- enable rapid iteration with values that can be updated as the script runs


Inputs let you customize your [Node](/scripting/script-types/node-scripts), [Layout](/scripting/script-types/layout-scripts), and [Converter](/scripting/script-types/converter-scripts) scripts with unique data that can be bound to view model properties.

## Defining Inputs

To make new script inputs, add them to the type and set the defaults in the script's return function.

```lua
-- Define the script's data and inputs.
-- These properties will be available in `self`
type MyScript = {
  myNumber: Input<number>,
  myViewModel: Input<Data.Points>,
  myArtboard: Input<Artboard<Data.MyNestedArtboard>>,
  -- This will be accessable via self, but not in the inputs panel
  myString: string,
}

function init(self: SnakeGame): boolean
  print("myString", self.myString)
  print("myNumber", self.myNumber)
  print("myColor", self.myColor)
  print("myViewModel value", self.myViewModel.someString.value)
  print("myViewModel value", self.myArtboard.data.someEnum.value)

  return true
end

return function(): Drawing<MyDrawing>
  return {
    init = init,
    draw = draw,
    myString = "Rive for president!"
    -- Sets default value when creating a new instance of the script
    -- This will be overridden by a value set in the script's inputs
    myNumber = 0,
    myColor = Color.rgba(255, 255, 0, 255), -- 0xFFFFFF00
  
    -- Use late() to mark this input as assigned at runtime
    myViewModel = late(),
    myArtboard = late()
  }
end

```

<Tip>
  Using inputs, instances of Artboards can be added to your scene at runtime. See [Instantiating Components](/scripting/script-types/node-scripts#instanting-components).
</Tip>

## Setting Input Values

To access the input properties in the right sidebar of the editor, select your [Node](/scripting/script-types/node-scripts) or [Layout script](/scripting/script-types/layout-scripts) in the Hierarchy Panel or the [Converter](/scripting/script-types/converter-scripts) in the Data Panel.

**Nodes and Layouts:**

[TO DO - image]

**Converter:**

![Converter script input](/images/scripting/converter-script-input.png)

## Data Binding Inputs

Data Binding inputs allows you to change and listen for changes to view model properties.

To view and update inputs, right-click the input field in right sidebar and choose **Data Bind**.

TO DO - VMs need a property of that VM type to refer to

<Tip>
  Bound Inputs support [Target to Source, Source to Target, and 2-way Data Binding](/editor/data-binding/overview#binding).
</Tip>

![Data bind a converter input](/images/scripting/converter-script-input-data-binding.png)

## Listening for Changes to Inputs

The `update` function fires every time any input changes.

```lua
function update(self: MyDrawing)
  print('An update changed')
end
```

You can also listen for changes to specific properties:

```lua
function handleMyStringChanged()
  print('myString changed!')
end

function handleMyNumberChanged(myNumber: number)
  print('myNumber changed!', myNumber)
end

function init(self: MyApp): boolean
  -- handleMyStringChanged fires when self.myString changes
  local myString = self.myString
  myString:addListener(handleMyStringChanged)

  -- Pass a parameter to the handleMyStringChanged callback
  local myNumber = self.myNumber
  myNumber:addListener(myNumber.value, handleMyNumberChanged)

  return true
end
```

